"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/get-it";
exports.ids = ["vendor-chunks/get-it"];
exports.modules = {

/***/ "(ssr)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-2bJolbLg.cjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/get-it/dist/_chunks/defaultOptionsValidator-2bJolbLg.cjs ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nconst isReactNative = typeof navigator === \"undefined\" ? false : navigator.product === \"ReactNative\";\nconst defaultOptions = {\n    timeout: isReactNative ? 6e4 : 12e4\n};\nconst processOptions = function processOptions2(opts) {\n    const options = {\n        ...defaultOptions,\n        ...typeof opts === \"string\" ? {\n            url: opts\n        } : opts\n    };\n    const { searchParams } = new URL(options.url, \"http://localhost\");\n    options.timeout = normalizeTimeout(options.timeout);\n    if (options.query) {\n        for (const [key, value] of Object.entries(options.query)){\n            if (value !== void 0) {\n                if (Array.isArray(value)) {\n                    for (const v of value){\n                        searchParams.append(key, v);\n                    }\n                } else {\n                    searchParams.append(key, value);\n                }\n            }\n        }\n    }\n    const [url] = options.url.split(\"?\");\n    const search = searchParams.toString();\n    if (search) {\n        options.url = \"\".concat(url, \"?\").concat(search);\n    }\n    options.method = options.body && !options.method ? \"POST\" : (options.method || \"GET\").toUpperCase();\n    return options;\n};\nfunction normalizeTimeout(time) {\n    if (time === false || time === 0) {\n        return false;\n    }\n    if (time.connect || time.socket) {\n        return time;\n    }\n    const delay = Number(time);\n    if (isNaN(delay)) {\n        return normalizeTimeout(defaultOptions.timeout);\n    }\n    return {\n        connect: delay,\n        socket: delay\n    };\n}\nconst validUrl = /^https?:\\/\\//i;\nconst validateOptions = function validateOptions2(options) {\n    if (!validUrl.test(options.url)) {\n        throw new Error('\"'.concat(options.url, '\" is not a valid URL'));\n    }\n};\nexports.processOptions = processOptions;\nexports.validateOptions = validateOptions; //# sourceMappingURL=defaultOptionsValidator-2bJolbLg.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvX2NodW5rcy9kZWZhdWx0T3B0aW9uc1ZhbGlkYXRvci0yYkpvbGJMZy5janMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxnQkFBZ0IsT0FBT0MsY0FBYyxjQUFjLFFBQVFBLFVBQVVDLE9BQU8sS0FBSztBQUN2RixNQUFNQyxpQkFBaUI7SUFDckJDLFNBQVNKLGdCQUFnQixNQUFNO0FBQ2pDO0FBQ0EsTUFBTUssaUJBQWlCLFNBQVNDLGdCQUFnQkMsSUFBSTtJQUNsRCxNQUFNQyxVQUFVO1FBQ2QsR0FBR0wsY0FBYztRQUNqQixHQUFJLE9BQU9JLFNBQVMsV0FBVztZQUM3QkUsS0FBS0Y7UUFDUCxJQUFJQSxJQUFJO0lBQ1Y7SUFDQSxNQUFNLEVBQ0pHLFlBQVksRUFDYixHQUFHLElBQUlDLElBQUlILFFBQVFDLEdBQUcsRUFBRTtJQUN6QkQsUUFBUUosT0FBTyxHQUFHUSxpQkFBaUJKLFFBQVFKLE9BQU87SUFDbEQsSUFBSUksUUFBUUssS0FBSyxFQUFFO1FBQ2pCLEtBQUssTUFBTSxDQUFDQyxLQUFLQyxNQUFNLElBQUlDLE9BQU9DLE9BQU8sQ0FBQ1QsUUFBUUssS0FBSyxFQUFHO1lBQ3hELElBQUlFLFVBQVUsS0FBSyxHQUFHO2dCQUNwQixJQUFJRyxNQUFNQyxPQUFPLENBQUNKLFFBQVE7b0JBQ3hCLEtBQUssTUFBTUssS0FBS0wsTUFBTzt3QkFDckJMLGFBQWFXLE1BQU0sQ0FBQ1AsS0FBS007b0JBQzNCO2dCQUNGLE9BQU87b0JBQ0xWLGFBQWFXLE1BQU0sQ0FBQ1AsS0FBS0M7Z0JBQzNCO1lBQ0Y7UUFDRjtJQUNGO0lBQ0EsTUFBTSxDQUFDTixJQUFJLEdBQUdELFFBQVFDLEdBQUcsQ0FBQ2EsS0FBSyxDQUFDO0lBQ2hDLE1BQU1DLFNBQVNiLGFBQWFjLFFBQVE7SUFDcEMsSUFBSUQsUUFBUTtRQUNWZixRQUFRQyxHQUFHLEdBQUcsR0FBR2dCLE1BQU0sQ0FBQ2hCLEtBQUssS0FBS2dCLE1BQU0sQ0FBQ0Y7SUFDM0M7SUFDQWYsUUFBUWtCLE1BQU0sR0FBR2xCLFFBQVFtQixJQUFJLElBQUksQ0FBQ25CLFFBQVFrQixNQUFNLEdBQUcsU0FBUyxDQUFDbEIsUUFBUWtCLE1BQU0sSUFBSSxLQUFJLEVBQUdFLFdBQVc7SUFDakcsT0FBT3BCO0FBQ1Q7QUFDQSxTQUFTSSxpQkFBaUJpQixJQUFJO0lBQzVCLElBQUlBLFNBQVMsU0FBU0EsU0FBUyxHQUFHO1FBQ2hDLE9BQU87SUFDVDtJQUNBLElBQUlBLEtBQUtDLE9BQU8sSUFBSUQsS0FBS0UsTUFBTSxFQUFFO1FBQy9CLE9BQU9GO0lBQ1Q7SUFDQSxNQUFNRyxRQUFRQyxPQUFPSjtJQUNyQixJQUFJSyxNQUFNRixRQUFRO1FBQ2hCLE9BQU9wQixpQkFBaUJULGVBQWVDLE9BQU87SUFDaEQ7SUFDQSxPQUFPO1FBQ0wwQixTQUFTRTtRQUNURCxRQUFRQztJQUNWO0FBQ0Y7QUFDQSxNQUFNRyxXQUFXO0FBQ2pCLE1BQU1DLGtCQUFrQixTQUFTQyxpQkFBaUI3QixPQUFPO0lBQ3ZELElBQUksQ0FBQzJCLFNBQVNHLElBQUksQ0FBQzlCLFFBQVFDLEdBQUcsR0FBRztRQUMvQixNQUFNLElBQUk4QixNQUFNLElBQUlkLE1BQU0sQ0FBQ2pCLFFBQVFDLEdBQUcsRUFBRTtJQUMxQztBQUNGO0FBQ0ErQixzQkFBc0IsR0FBR25DO0FBQ3pCbUMsdUJBQXVCLEdBQUdKLGlCQUMxQiw2REFBNkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMtY29tbWVyY2UteXQtYnktbWlrZS8uL25vZGVfbW9kdWxlcy9nZXQtaXQvZGlzdC9fY2h1bmtzL2RlZmF1bHRPcHRpb25zVmFsaWRhdG9yLTJiSm9sYkxnLmNqcz8wNjcyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaXNSZWFjdE5hdGl2ZSA9IHR5cGVvZiBuYXZpZ2F0b3IgPT09IFwidW5kZWZpbmVkXCIgPyBmYWxzZSA6IG5hdmlnYXRvci5wcm9kdWN0ID09PSBcIlJlYWN0TmF0aXZlXCI7XG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgdGltZW91dDogaXNSZWFjdE5hdGl2ZSA/IDZlNCA6IDEyZTRcbn07XG5jb25zdCBwcm9jZXNzT3B0aW9ucyA9IGZ1bmN0aW9uIHByb2Nlc3NPcHRpb25zMihvcHRzKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgLi4uKHR5cGVvZiBvcHRzID09PSBcInN0cmluZ1wiID8ge1xuICAgICAgdXJsOiBvcHRzXG4gICAgfSA6IG9wdHMpXG4gIH07XG4gIGNvbnN0IHtcbiAgICBzZWFyY2hQYXJhbXNcbiAgfSA9IG5ldyBVUkwob3B0aW9ucy51cmwsIFwiaHR0cDovL2xvY2FsaG9zdFwiKTtcbiAgb3B0aW9ucy50aW1lb3V0ID0gbm9ybWFsaXplVGltZW91dChvcHRpb25zLnRpbWVvdXQpO1xuICBpZiAob3B0aW9ucy5xdWVyeSkge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMucXVlcnkpKSB7XG4gICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBbdXJsXSA9IG9wdGlvbnMudXJsLnNwbGl0KFwiP1wiKTtcbiAgY29uc3Qgc2VhcmNoID0gc2VhcmNoUGFyYW1zLnRvU3RyaW5nKCk7XG4gIGlmIChzZWFyY2gpIHtcbiAgICBvcHRpb25zLnVybCA9IFwiXCIuY29uY2F0KHVybCwgXCI/XCIpLmNvbmNhdChzZWFyY2gpO1xuICB9XG4gIG9wdGlvbnMubWV0aG9kID0gb3B0aW9ucy5ib2R5ICYmICFvcHRpb25zLm1ldGhvZCA/IFwiUE9TVFwiIDogKG9wdGlvbnMubWV0aG9kIHx8IFwiR0VUXCIpLnRvVXBwZXJDYXNlKCk7XG4gIHJldHVybiBvcHRpb25zO1xufTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVRpbWVvdXQodGltZSkge1xuICBpZiAodGltZSA9PT0gZmFsc2UgfHwgdGltZSA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodGltZS5jb25uZWN0IHx8IHRpbWUuc29ja2V0KSB7XG4gICAgcmV0dXJuIHRpbWU7XG4gIH1cbiAgY29uc3QgZGVsYXkgPSBOdW1iZXIodGltZSk7XG4gIGlmIChpc05hTihkZWxheSkpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplVGltZW91dChkZWZhdWx0T3B0aW9ucy50aW1lb3V0KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGNvbm5lY3Q6IGRlbGF5LFxuICAgIHNvY2tldDogZGVsYXlcbiAgfTtcbn1cbmNvbnN0IHZhbGlkVXJsID0gL15odHRwcz86XFwvXFwvL2k7XG5jb25zdCB2YWxpZGF0ZU9wdGlvbnMgPSBmdW5jdGlvbiB2YWxpZGF0ZU9wdGlvbnMyKG9wdGlvbnMpIHtcbiAgaWYgKCF2YWxpZFVybC50ZXN0KG9wdGlvbnMudXJsKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignXCInLmNvbmNhdChvcHRpb25zLnVybCwgJ1wiIGlzIG5vdCBhIHZhbGlkIFVSTCcpKTtcbiAgfVxufTtcbmV4cG9ydHMucHJvY2Vzc09wdGlvbnMgPSBwcm9jZXNzT3B0aW9ucztcbmV4cG9ydHMudmFsaWRhdGVPcHRpb25zID0gdmFsaWRhdGVPcHRpb25zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdE9wdGlvbnNWYWxpZGF0b3ItMmJKb2xiTGcuY2pzLm1hcFxuIl0sIm5hbWVzIjpbImlzUmVhY3ROYXRpdmUiLCJuYXZpZ2F0b3IiLCJwcm9kdWN0IiwiZGVmYXVsdE9wdGlvbnMiLCJ0aW1lb3V0IiwicHJvY2Vzc09wdGlvbnMiLCJwcm9jZXNzT3B0aW9uczIiLCJvcHRzIiwib3B0aW9ucyIsInVybCIsInNlYXJjaFBhcmFtcyIsIlVSTCIsIm5vcm1hbGl6ZVRpbWVvdXQiLCJxdWVyeSIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZW50cmllcyIsIkFycmF5IiwiaXNBcnJheSIsInYiLCJhcHBlbmQiLCJzcGxpdCIsInNlYXJjaCIsInRvU3RyaW5nIiwiY29uY2F0IiwibWV0aG9kIiwiYm9keSIsInRvVXBwZXJDYXNlIiwidGltZSIsImNvbm5lY3QiLCJzb2NrZXQiLCJkZWxheSIsIk51bWJlciIsImlzTmFOIiwidmFsaWRVcmwiLCJ2YWxpZGF0ZU9wdGlvbnMiLCJ2YWxpZGF0ZU9wdGlvbnMyIiwidGVzdCIsIkVycm9yIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-2bJolbLg.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/get-it/dist/index.cjs":
/*!********************************************!*\
  !*** ./node_modules/get-it/dist/index.cjs ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar defaultOptionsValidator = __webpack_require__(/*! ./_chunks/defaultOptionsValidator-2bJolbLg.cjs */ \"(ssr)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-2bJolbLg.cjs\");\nvar decompressResponse = __webpack_require__(/*! decompress-response */ \"(ssr)/./node_modules/decompress-response/index.js\");\nvar follow = __webpack_require__(/*! follow-redirects */ \"(ssr)/./node_modules/follow-redirects/index.js\");\nvar http = __webpack_require__(/*! http */ \"http\");\nvar https = __webpack_require__(/*! https */ \"https\");\nvar toStream = __webpack_require__(/*! into-stream */ \"(ssr)/./node_modules/into-stream/index.js\");\nvar isStream = __webpack_require__(/*! is-stream */ \"(ssr)/./node_modules/is-stream/index.js\");\nvar progressStream = __webpack_require__(/*! progress-stream */ \"(ssr)/./node_modules/progress-stream/index.js\");\nvar qs = __webpack_require__(/*! querystring */ \"querystring\");\nvar url = __webpack_require__(/*! url */ \"url\");\nvar tunnel = __webpack_require__(/*! tunnel-agent */ \"(ssr)/./node_modules/tunnel-agent/index.js\");\nfunction _interopDefaultCompat(e) {\n    return e && typeof e === \"object\" && \"default\" in e ? e : {\n        default: e\n    };\n}\nfunction _interopNamespaceCompat(e) {\n    if (e && typeof e === \"object\" && \"default\" in e) return e;\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function(k) {\n            if (k !== \"default\") {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function() {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    }\n    n.default = e;\n    return Object.freeze(n);\n}\nvar decompressResponse__default = /*#__PURE__*/ _interopDefaultCompat(decompressResponse);\nvar follow__default = /*#__PURE__*/ _interopDefaultCompat(follow);\nvar http__default = /*#__PURE__*/ _interopDefaultCompat(http);\nvar https__default = /*#__PURE__*/ _interopDefaultCompat(https);\nvar toStream__default = /*#__PURE__*/ _interopDefaultCompat(toStream);\nvar isStream__default = /*#__PURE__*/ _interopDefaultCompat(isStream);\nvar progressStream__default = /*#__PURE__*/ _interopDefaultCompat(progressStream);\nvar qs__default = /*#__PURE__*/ _interopDefaultCompat(qs);\nvar url__default = /*#__PURE__*/ _interopDefaultCompat(url);\nvar tunnel__namespace = /*#__PURE__*/ _interopNamespaceCompat(tunnel);\nconst middlewareReducer = (middleware)=>function applyMiddleware(hook, defaultValue) {\n        const bailEarly = hook === \"onError\";\n        let value = defaultValue;\n        for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){\n            args[_key - 2] = arguments[_key];\n        }\n        for(let i = 0; i < middleware[hook].length; i++){\n            const handler = middleware[hook][i];\n            value = handler(value, ...args);\n            if (bailEarly && !value) {\n                break;\n            }\n        }\n        return value;\n    };\nfunction createPubSub() {\n    const subscribers = /* @__PURE__ */ Object.create(null);\n    let nextId = 0;\n    function subscribe(subscriber) {\n        const id = nextId++;\n        subscribers[id] = subscriber;\n        return function unsubscribe() {\n            delete subscribers[id];\n        };\n    }\n    function publish(event) {\n        for(const id in subscribers){\n            subscribers[id](event);\n        }\n    }\n    return {\n        publish,\n        subscribe\n    };\n}\nconst channelNames = [\n    \"request\",\n    \"response\",\n    \"progress\",\n    \"error\",\n    \"abort\"\n];\nconst middlehooks = [\n    \"processOptions\",\n    \"validateOptions\",\n    \"interceptRequest\",\n    \"finalizeOptions\",\n    \"onRequest\",\n    \"onResponse\",\n    \"onError\",\n    \"onReturn\",\n    \"onHeaders\"\n];\nfunction createRequester(initMiddleware, httpRequest) {\n    const loadedMiddleware = [];\n    const middleware = middlehooks.reduce((ware, name)=>{\n        ware[name] = ware[name] || [];\n        return ware;\n    }, {\n        processOptions: [\n            defaultOptionsValidator.processOptions\n        ],\n        validateOptions: [\n            defaultOptionsValidator.validateOptions\n        ]\n    });\n    function request(opts) {\n        const onResponse = (reqErr, res, ctx)=>{\n            let error = reqErr;\n            let response = res;\n            if (!error) {\n                try {\n                    response = applyMiddleware(\"onResponse\", res, ctx);\n                } catch (err) {\n                    response = null;\n                    error = err;\n                }\n            }\n            error = error && applyMiddleware(\"onError\", error, ctx);\n            if (error) {\n                channels.error.publish(error);\n            } else if (response) {\n                channels.response.publish(response);\n            }\n        };\n        const channels = channelNames.reduce((target, name)=>{\n            target[name] = createPubSub();\n            return target;\n        }, {});\n        const applyMiddleware = middlewareReducer(middleware);\n        const options = applyMiddleware(\"processOptions\", opts);\n        applyMiddleware(\"validateOptions\", options);\n        const context = {\n            options,\n            channels,\n            applyMiddleware\n        };\n        let ongoingRequest;\n        const unsubscribe = channels.request.subscribe((ctx)=>{\n            ongoingRequest = httpRequest(ctx, (err, res)=>onResponse(err, res, ctx));\n        });\n        channels.abort.subscribe(()=>{\n            unsubscribe();\n            if (ongoingRequest) {\n                ongoingRequest.abort();\n            }\n        });\n        const returnValue = applyMiddleware(\"onReturn\", channels, context);\n        if (returnValue === channels) {\n            channels.request.publish(context);\n        }\n        return returnValue;\n    }\n    request.use = function use(newMiddleware) {\n        if (!newMiddleware) {\n            throw new Error(\"Tried to add middleware that resolved to falsey value\");\n        }\n        if (typeof newMiddleware === \"function\") {\n            throw new Error(\"Tried to add middleware that was a function. It probably expects you to pass options to it.\");\n        }\n        if (newMiddleware.onReturn && middleware.onReturn.length > 0) {\n            throw new Error(\"Tried to add new middleware with `onReturn` handler, but another handler has already been registered for this event\");\n        }\n        middlehooks.forEach((key)=>{\n            if (newMiddleware[key]) {\n                middleware[key].push(newMiddleware[key]);\n            }\n        });\n        loadedMiddleware.push(newMiddleware);\n        return request;\n    };\n    request.clone = ()=>createRequester(loadedMiddleware, httpRequest);\n    initMiddleware.forEach(request.use);\n    return request;\n}\nfunction lowerCaseHeaders(headers) {\n    return Object.keys(headers || {}).reduce((acc, header)=>{\n        acc[header.toLowerCase()] = headers[header];\n        return acc;\n    }, {});\n}\nfunction formatHostname(hostname) {\n    return hostname.replace(/^\\.*/, \".\").toLowerCase();\n}\nfunction parseNoProxyZone(zoneStr) {\n    const zone = zoneStr.trim().toLowerCase();\n    const zoneParts = zone.split(\":\", 2);\n    const zoneHost = formatHostname(zoneParts[0]);\n    const zonePort = zoneParts[1];\n    const hasPort = zone.indexOf(\":\") > -1;\n    return {\n        hostname: zoneHost,\n        port: zonePort,\n        hasPort\n    };\n}\nfunction uriInNoProxy(uri, noProxy) {\n    const port = uri.port || (uri.protocol === \"https:\" ? \"443\" : \"80\");\n    const hostname = formatHostname(uri.hostname);\n    const noProxyList = noProxy.split(\",\");\n    return noProxyList.map(parseNoProxyZone).some((noProxyZone)=>{\n        const isMatchedAt = hostname.indexOf(noProxyZone.hostname);\n        const hostnameMatched = isMatchedAt > -1 && isMatchedAt === hostname.length - noProxyZone.hostname.length;\n        if (noProxyZone.hasPort) {\n            return port === noProxyZone.port && hostnameMatched;\n        }\n        return hostnameMatched;\n    });\n}\nfunction getProxyFromUri(uri) {\n    const noProxy = process.env.NO_PROXY || process.env.no_proxy || \"\";\n    if (noProxy === \"*\") {\n        return null;\n    }\n    if (noProxy !== \"\" && uriInNoProxy(uri, noProxy)) {\n        return null;\n    }\n    if (uri.protocol === \"http:\") {\n        return process.env.HTTP_PROXY || process.env.http_proxy || null;\n    }\n    if (uri.protocol === \"https:\") {\n        return process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy || null;\n    }\n    return null;\n}\nfunction getHostFromUri(uri) {\n    let host = uri.host;\n    if (uri.port) {\n        if (uri.port === \"80\" && uri.protocol === \"http:\" || uri.port === \"443\" && uri.protocol === \"https:\") {\n            host = uri.hostname;\n        }\n    }\n    return host;\n}\nfunction getHostHeaderWithPort(uri) {\n    const port = uri.port || (uri.protocol === \"https:\" ? \"443\" : \"80\");\n    return \"\".concat(uri.hostname, \":\").concat(port);\n}\nfunction rewriteUriForProxy(reqOpts, uri, proxy) {\n    const headers = reqOpts.headers || {};\n    const options = Object.assign({}, reqOpts, {\n        headers\n    });\n    headers.host = headers.host || getHostHeaderWithPort(uri);\n    options.protocol = proxy.protocol || options.protocol;\n    options.hostname = proxy.host.replace(/:\\d+/, \"\");\n    options.port = proxy.port;\n    options.host = getHostFromUri(Object.assign({}, uri, proxy));\n    options.href = \"\".concat(options.protocol, \"//\").concat(options.host).concat(options.path);\n    options.path = url__default.default.format(uri);\n    return options;\n}\nfunction getProxyOptions(options) {\n    let proxy;\n    if (options.hasOwnProperty(\"proxy\")) {\n        proxy = options.proxy;\n    } else {\n        const uri = url__default.default.parse(options.url);\n        proxy = getProxyFromUri(uri);\n    }\n    return typeof proxy === \"string\" ? url__default.default.parse(proxy) : proxy;\n}\n/*! simple-concat. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ function concat(stream, cb) {\n    const chunks = [];\n    stream.on(\"data\", function(chunk) {\n        chunks.push(chunk);\n    });\n    stream.once(\"end\", function() {\n        if (cb) cb(null, Buffer.concat(chunks));\n        cb = null;\n    });\n    stream.once(\"error\", function(err) {\n        if (cb) cb(err);\n        cb = null;\n    });\n}\nfunction timedOut(req, time) {\n    if (req.timeoutTimer) {\n        return req;\n    }\n    const delays = isNaN(time) ? time : {\n        socket: time,\n        connect: time\n    };\n    const hostHeader = req.getHeader(\"host\");\n    const host = hostHeader ? \" to \" + hostHeader : \"\";\n    if (delays.connect !== void 0) {\n        req.timeoutTimer = setTimeout(function timeoutHandler() {\n            req.abort();\n            const e = new Error(\"Connection timed out on request\" + host);\n            e.code = \"ETIMEDOUT\";\n            req.emit(\"error\", e);\n        }, delays.connect);\n    }\n    req.on(\"socket\", function assign(socket) {\n        if (!(socket.connecting || socket._connecting)) {\n            connect();\n            return;\n        }\n        socket.once(\"connect\", connect);\n    });\n    function clear() {\n        if (req.timeoutTimer) {\n            clearTimeout(req.timeoutTimer);\n            req.timeoutTimer = null;\n        }\n    }\n    function connect() {\n        clear();\n        if (delays.socket !== void 0) {\n            req.setTimeout(delays.socket, function socketTimeoutHandler() {\n                req.abort();\n                const e = new Error(\"Socket timed out on request\" + host);\n                e.code = \"ESOCKETTIMEDOUT\";\n                req.emit(\"error\", e);\n            });\n        }\n    }\n    return req.on(\"error\", clear);\n}\nconst uriParts = [\n    \"protocol\",\n    \"slashes\",\n    \"auth\",\n    \"host\",\n    \"port\",\n    \"hostname\",\n    \"hash\",\n    \"search\",\n    \"query\",\n    \"pathname\",\n    \"path\",\n    \"href\"\n];\nconst defaultProxyHeaderWhiteList = [\n    \"accept\",\n    \"accept-charset\",\n    \"accept-encoding\",\n    \"accept-language\",\n    \"accept-ranges\",\n    \"cache-control\",\n    \"content-encoding\",\n    \"content-language\",\n    \"content-location\",\n    \"content-md5\",\n    \"content-range\",\n    \"content-type\",\n    \"connection\",\n    \"date\",\n    \"expect\",\n    \"max-forwards\",\n    \"pragma\",\n    \"referer\",\n    \"te\",\n    \"user-agent\",\n    \"via\"\n];\nconst defaultProxyHeaderExclusiveList = [\n    \"proxy-authorization\"\n];\nfunction shouldEnable(options) {\n    if (typeof options.tunnel !== \"undefined\") {\n        return Boolean(options.tunnel);\n    }\n    const uri = url__default.default.parse(options.url);\n    if (uri.protocol === \"https:\") {\n        return true;\n    }\n    return false;\n}\nfunction applyAgent() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let proxy = arguments.length > 1 ? arguments[1] : undefined;\n    const options = Object.assign({}, opts);\n    const proxyHeaderWhiteList = defaultProxyHeaderWhiteList.concat(options.proxyHeaderWhiteList || []).map((header)=>header.toLowerCase());\n    const proxyHeaderExclusiveList = defaultProxyHeaderExclusiveList.concat(options.proxyHeaderExclusiveList || []).map((header)=>header.toLowerCase());\n    const proxyHeaders = getAllowedProxyHeaders(options.headers, proxyHeaderWhiteList);\n    proxyHeaders.host = constructProxyHost(options);\n    options.headers = Object.keys(options.headers || {}).reduce((headers, header)=>{\n        const isAllowed = proxyHeaderExclusiveList.indexOf(header.toLowerCase()) === -1;\n        if (isAllowed) {\n            headers[header] = options.headers[header];\n        }\n        return headers;\n    }, {});\n    const tunnelFn = getTunnelFn(options, proxy);\n    const tunnelOptions = constructTunnelOptions(options, proxy, proxyHeaders);\n    options.agent = tunnelFn(tunnelOptions);\n    return options;\n}\nfunction getTunnelFn(options, proxy) {\n    const uri = getUriParts(options);\n    const tunnelFnName = constructTunnelFnName(uri, proxy);\n    return tunnel__namespace[tunnelFnName];\n}\nfunction getUriParts(options) {\n    return uriParts.reduce((uri, part)=>{\n        uri[part] = options[part];\n        return uri;\n    }, {});\n}\nfunction constructTunnelFnName(uri, proxy) {\n    const uriProtocol = uri.protocol === \"https:\" ? \"https\" : \"http\";\n    const proxyProtocol = proxy.protocol === \"https:\" ? \"Https\" : \"Http\";\n    return \"\".concat(uriProtocol, \"Over\").concat(proxyProtocol);\n}\nfunction constructProxyHost(uri) {\n    const port = uri.port;\n    const protocol = uri.protocol;\n    let proxyHost = \"\".concat(uri.hostname, \":\");\n    if (port) {\n        proxyHost += port;\n    } else if (protocol === \"https:\") {\n        proxyHost += \"443\";\n    } else {\n        proxyHost += \"80\";\n    }\n    return proxyHost;\n}\nfunction getAllowedProxyHeaders(headers, whiteList) {\n    return Object.keys(headers).filter((header)=>whiteList.indexOf(header.toLowerCase()) !== -1).reduce((set, header)=>{\n        set[header] = headers[header];\n        return set;\n    }, {});\n}\nfunction constructTunnelOptions(options, proxy, proxyHeaders) {\n    return {\n        proxy: {\n            host: proxy.hostname,\n            port: +proxy.port,\n            proxyAuth: proxy.auth,\n            headers: proxyHeaders\n        },\n        headers: options.headers,\n        ca: options.ca,\n        cert: options.cert,\n        key: options.key,\n        passphrase: options.passphrase,\n        pfx: options.pfx,\n        ciphers: options.ciphers,\n        rejectUnauthorized: options.rejectUnauthorized,\n        secureOptions: options.secureOptions,\n        secureProtocol: options.secureProtocol\n    };\n}\nconst adapter = \"node\";\nconst reduceResponse = (res, reqUrl, method, body)=>({\n        body,\n        url: reqUrl,\n        method,\n        headers: res.headers,\n        statusCode: res.statusCode,\n        statusMessage: res.statusMessage\n    });\nconst httpRequester = (context, cb)=>{\n    const { options } = context;\n    const uri = Object.assign({}, url__default.default.parse(options.url));\n    if (typeof fetch === \"function\" && options.fetch) {\n        const controller = new AbortController();\n        const reqOpts2 = context.applyMiddleware(\"finalizeOptions\", {\n            ...uri,\n            method: options.method,\n            headers: {\n                ...typeof options.fetch === \"object\" && options.fetch.headers ? lowerCaseHeaders(options.fetch.headers) : {},\n                ...lowerCaseHeaders(options.headers)\n            },\n            maxRedirects: options.maxRedirects\n        });\n        const fetchOpts = {\n            credentials: options.withCredentials ? \"include\" : \"omit\",\n            ...typeof options.fetch === \"object\" ? options.fetch : {},\n            method: reqOpts2.method,\n            headers: reqOpts2.headers,\n            body: options.body,\n            signal: controller.signal\n        };\n        const injectedResponse2 = context.applyMiddleware(\"interceptRequest\", void 0, {\n            adapter,\n            context\n        });\n        if (injectedResponse2) {\n            const cbTimer = setTimeout(cb, 0, null, injectedResponse2);\n            const cancel = ()=>clearTimeout(cbTimer);\n            return {\n                abort: cancel\n            };\n        }\n        const request2 = fetch(options.url, fetchOpts);\n        context.applyMiddleware(\"onRequest\", {\n            options,\n            adapter,\n            request: request2,\n            context\n        });\n        request2.then(async (res)=>{\n            const body = options.rawBody ? res.body : await res.text();\n            const headers = {};\n            res.headers.forEach((value, key)=>{\n                headers[key] = value;\n            });\n            cb(null, {\n                body,\n                url: res.url,\n                method: options.method,\n                headers,\n                statusCode: res.status,\n                statusMessage: res.statusText\n            });\n        }).catch((err)=>{\n            if (err.name == \"AbortError\") return;\n            cb(err);\n        });\n        return {\n            abort: ()=>controller.abort()\n        };\n    }\n    const bodyType = isStream__default.default(options.body) ? \"stream\" : typeof options.body;\n    if (bodyType !== \"undefined\" && bodyType !== \"stream\" && bodyType !== \"string\" && !Buffer.isBuffer(options.body)) {\n        throw new Error(\"Request body must be a string, buffer or stream, got \".concat(bodyType));\n    }\n    const lengthHeader = {};\n    if (options.bodySize) {\n        lengthHeader[\"content-length\"] = options.bodySize;\n    } else if (options.body && bodyType !== \"stream\") {\n        lengthHeader[\"content-length\"] = Buffer.byteLength(options.body);\n    }\n    let aborted = false;\n    const callback = (err, res)=>!aborted && cb(err, res);\n    context.channels.abort.subscribe(()=>{\n        aborted = true;\n    });\n    let reqOpts = Object.assign({}, uri, {\n        method: options.method,\n        headers: Object.assign({}, lowerCaseHeaders(options.headers), lengthHeader),\n        maxRedirects: options.maxRedirects\n    });\n    const proxy = getProxyOptions(options);\n    const tunnel = proxy && shouldEnable(options);\n    const injectedResponse = context.applyMiddleware(\"interceptRequest\", void 0, {\n        adapter,\n        context\n    });\n    if (injectedResponse) {\n        const cbTimer = setImmediate(callback, null, injectedResponse);\n        const abort = ()=>clearImmediate(cbTimer);\n        return {\n            abort\n        };\n    }\n    if (options.maxRedirects !== 0) {\n        reqOpts.maxRedirects = options.maxRedirects || 5;\n    }\n    if (proxy && tunnel) {\n        reqOpts = applyAgent(reqOpts, proxy);\n    } else if (proxy && !tunnel) {\n        reqOpts = rewriteUriForProxy(reqOpts, uri, proxy);\n    }\n    if (!tunnel && proxy && proxy.auth && !reqOpts.headers[\"proxy-authorization\"]) {\n        const [username, password] = proxy.auth.username ? [\n            proxy.auth.username,\n            proxy.auth.password\n        ] : proxy.auth.split(\":\").map((item)=>qs__default.default.unescape(item));\n        const auth = Buffer.from(\"\".concat(username, \":\").concat(password), \"utf8\");\n        const authBase64 = auth.toString(\"base64\");\n        reqOpts.headers[\"proxy-authorization\"] = \"Basic \".concat(authBase64);\n    }\n    const transport = getRequestTransport(reqOpts, proxy, tunnel);\n    if (typeof options.debug === \"function\" && proxy) {\n        options.debug(\"Proxying using %s\", reqOpts.agent ? \"tunnel agent\" : \"\".concat(reqOpts.host, \":\").concat(reqOpts.port));\n    }\n    const tryCompressed = reqOpts.method !== \"HEAD\";\n    if (tryCompressed && !reqOpts.headers[\"accept-encoding\"] && options.compress !== false) {\n        reqOpts.headers[\"accept-encoding\"] = \"br, gzip, deflate\";\n    }\n    const finalOptions = context.applyMiddleware(\"finalizeOptions\", reqOpts);\n    const request = transport.request(finalOptions, (response)=>{\n        const res = tryCompressed ? decompressResponse__default.default(response) : response;\n        const resStream = context.applyMiddleware(\"onHeaders\", res, {\n            headers: response.headers,\n            adapter,\n            context\n        });\n        const reqUrl = \"responseUrl\" in response ? response.responseUrl : options.url;\n        if (options.stream) {\n            callback(null, reduceResponse(res, reqUrl, reqOpts.method, resStream));\n            return;\n        }\n        concat(resStream, (err, data)=>{\n            if (err) {\n                return callback(err);\n            }\n            const body = options.rawBody ? data : data.toString();\n            const reduced = reduceResponse(res, reqUrl, reqOpts.method, body);\n            return callback(null, reduced);\n        });\n    });\n    if (options.timeout) {\n        timedOut(request, options.timeout);\n    }\n    request.once(\"error\", callback);\n    const { bodyStream, progress } = getProgressStream(options);\n    context.applyMiddleware(\"onRequest\", {\n        options,\n        adapter,\n        request,\n        context,\n        progress\n    });\n    if (bodyStream) {\n        bodyStream.pipe(request);\n    } else {\n        request.end(options.body);\n    }\n    return {\n        abort: ()=>request.abort()\n    };\n};\nfunction getProgressStream(options) {\n    if (!options.body) {\n        return {};\n    }\n    const bodyIsStream = isStream__default.default(options.body);\n    const length = options.bodySize || (bodyIsStream ? null : Buffer.byteLength(options.body));\n    if (!length) {\n        return bodyIsStream ? {\n            bodyStream: options.body\n        } : {};\n    }\n    const progress = progressStream__default.default({\n        time: 16,\n        length\n    });\n    const bodyStream = bodyIsStream ? options.body : toStream__default.default(options.body);\n    return {\n        bodyStream: bodyStream.pipe(progress),\n        progress\n    };\n}\nfunction getRequestTransport(reqOpts, proxy, tunnel) {\n    const isHttpsRequest = reqOpts.protocol === \"https:\";\n    const transports = reqOpts.maxRedirects === 0 ? {\n        http: http__default.default,\n        https: https__default.default\n    } : {\n        http: follow__default.default.http,\n        https: follow__default.default.https\n    };\n    if (!proxy || tunnel) {\n        return isHttpsRequest ? transports.https : transports.http;\n    }\n    let isHttpsProxy = proxy.port === 443;\n    if (proxy.protocol) {\n        isHttpsProxy = /^https:?/.test(proxy.protocol);\n    }\n    return isHttpsProxy ? transports.https : transports.http;\n}\nconst getIt = function() {\n    let initMiddleware = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let httpRequest = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : httpRequester;\n    return createRequester(initMiddleware, httpRequest);\n};\nconst environment = \"node\";\nexports.adapter = adapter;\nexports.environment = environment;\nexports.getIt = getIt; //# sourceMappingURL=index.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGLElBQUlDLDBCQUEwQkMsbUJBQU9BLENBQUM7QUFDdEMsSUFBSUMscUJBQXFCRCxtQkFBT0EsQ0FBQztBQUNqQyxJQUFJRSxTQUFTRixtQkFBT0EsQ0FBQztBQUNyQixJQUFJRyxPQUFPSCxtQkFBT0EsQ0FBQztBQUNuQixJQUFJSSxRQUFRSixtQkFBT0EsQ0FBQztBQUNwQixJQUFJSyxXQUFXTCxtQkFBT0EsQ0FBQztBQUN2QixJQUFJTSxXQUFXTixtQkFBT0EsQ0FBQztBQUN2QixJQUFJTyxpQkFBaUJQLG1CQUFPQSxDQUFDO0FBQzdCLElBQUlRLEtBQUtSLG1CQUFPQSxDQUFDO0FBQ2pCLElBQUlTLE1BQU1ULG1CQUFPQSxDQUFDO0FBQ2xCLElBQUlVLFNBQVNWLG1CQUFPQSxDQUFDO0FBQ3JCLFNBQVNXLHNCQUFzQkMsQ0FBQztJQUM5QixPQUFPQSxLQUFLLE9BQU9BLE1BQU0sWUFBWSxhQUFhQSxJQUFJQSxJQUFJO1FBQ3hEQyxTQUFTRDtJQUNYO0FBQ0Y7QUFDQSxTQUFTRSx3QkFBd0JGLENBQUM7SUFDaEMsSUFBSUEsS0FBSyxPQUFPQSxNQUFNLFlBQVksYUFBYUEsR0FBRyxPQUFPQTtJQUN6RCxJQUFJRyxJQUFJcEIsT0FBT3FCLE1BQU0sQ0FBQztJQUN0QixJQUFJSixHQUFHO1FBQ0xqQixPQUFPc0IsSUFBSSxDQUFDTCxHQUFHTSxPQUFPLENBQUMsU0FBVUMsQ0FBQztZQUNoQyxJQUFJQSxNQUFNLFdBQVc7Z0JBQ25CLElBQUlDLElBQUl6QixPQUFPMEIsd0JBQXdCLENBQUNULEdBQUdPO2dCQUMzQ3hCLE9BQU9DLGNBQWMsQ0FBQ21CLEdBQUdJLEdBQUdDLEVBQUVFLEdBQUcsR0FBR0YsSUFBSTtvQkFDdENHLFlBQVk7b0JBQ1pELEtBQUs7d0JBQ0gsT0FBT1Ys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WyJ3ZWJwYWNrOi8vbmV4dGpzLWNvbW1lcmNlLXl0LWJ5LW1pa2UvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvaW5kZXguY2pzPzI5YTYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBkZWZhdWx0T3B0aW9uc1ZhbGlkYXRvciA9IHJlcXVpcmUoJy4vX2NodW5rcy9kZWZhdWx0T3B0aW9uc1ZhbGlkYXRvci0yYkpvbGJMZy5janMnKTtcbnZhciBkZWNvbXByZXNzUmVzcG9uc2UgPSByZXF1aXJlKCdkZWNvbXByZXNzLXJlc3BvbnNlJyk7XG52YXIgZm9sbG93ID0gcmVxdWlyZSgnZm9sbG93LXJlZGlyZWN0cycpO1xudmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG52YXIgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xudmFyIHRvU3RyZWFtID0gcmVxdWlyZSgnaW50by1zdHJlYW0nKTtcbnZhciBpc1N0cmVhbSA9IHJlcXVpcmUoJ2lzLXN0cmVhbScpO1xudmFyIHByb2dyZXNzU3RyZWFtID0gcmVxdWlyZSgncHJvZ3Jlc3Mtc3RyZWFtJyk7XG52YXIgcXMgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpO1xudmFyIHR1bm5lbCA9IHJlcXVpcmUoJ3R1bm5lbC1hZ2VudCcpO1xuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0Q29tcGF0KGUpIHtcbiAgcmV0dXJuIGUgJiYgdHlwZW9mIGUgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBlID8gZSA6IHtcbiAgICBkZWZhdWx0OiBlXG4gIH07XG59XG5mdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZUNvbXBhdChlKSB7XG4gIGlmIChlICYmIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZSkgcmV0dXJuIGU7XG4gIHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKGUpIHtcbiAgICBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGVba107XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBuLmRlZmF1bHQgPSBlO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbn1cbnZhciBkZWNvbXByZXNzUmVzcG9uc2VfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0Q29tcGF0KGRlY29tcHJlc3NSZXNwb25zZSk7XG52YXIgZm9sbG93X19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdENvbXBhdChmb2xsb3cpO1xudmFyIGh0dHBfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0Q29tcGF0KGh0dHApO1xudmFyIGh0dHBzX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdENvbXBhdChodHRwcyk7XG52YXIgdG9TdHJlYW1fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0Q29tcGF0KHRvU3RyZWFtKTtcbnZhciBpc1N0cmVhbV9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRDb21wYXQoaXNTdHJlYW0pO1xudmFyIHByb2dyZXNzU3RyZWFtX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdENvbXBhdChwcm9ncmVzc1N0cmVhbSk7XG52YXIgcXNfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0Q29tcGF0KHFzKTtcbnZhciB1cmxfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0Q29tcGF0KHVybCk7XG52YXIgdHVubmVsX19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2VDb21wYXQodHVubmVsKTtcbmNvbnN0IG1pZGRsZXdhcmVSZWR1Y2VyID0gbWlkZGxld2FyZSA9PiBmdW5jdGlvbiBhcHBseU1pZGRsZXdhcmUoaG9vaywgZGVmYXVsdFZhbHVlKSB7XG4gIGNvbnN0IGJhaWxFYXJseSA9IGhvb2sgPT09IFwib25FcnJvclwiO1xuICBsZXQgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG1pZGRsZXdhcmVbaG9va10ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBoYW5kbGVyID0gbWlkZGxld2FyZVtob29rXVtpXTtcbiAgICB2YWx1ZSA9IGhhbmRsZXIodmFsdWUsIC4uLmFyZ3MpO1xuICAgIGlmIChiYWlsRWFybHkgJiYgIXZhbHVlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufTtcbmZ1bmN0aW9uIGNyZWF0ZVB1YlN1YigpIHtcbiAgY29uc3Qgc3Vic2NyaWJlcnMgPSAvKiBAX19QVVJFX18gKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuICBsZXQgbmV4dElkID0gMDtcbiAgZnVuY3Rpb24gc3Vic2NyaWJlKHN1YnNjcmliZXIpIHtcbiAgICBjb25zdCBpZCA9IG5leHRJZCsrO1xuICAgIHN1YnNjcmliZXJzW2lkXSA9IHN1YnNjcmliZXI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgZGVsZXRlIHN1YnNjcmliZXJzW2lkXTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHB1Ymxpc2goZXZlbnQpIHtcbiAgICBmb3IgKGNvbnN0IGlkIGluIHN1YnNjcmliZXJzKSB7XG4gICAgICBzdWJzY3JpYmVyc1tpZF0oZXZlbnQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHB1Ymxpc2gsXG4gICAgc3Vic2NyaWJlXG4gIH07XG59XG5jb25zdCBjaGFubmVsTmFtZXMgPSBbXCJyZXF1ZXN0XCIsIFwicmVzcG9uc2VcIiwgXCJwcm9ncmVzc1wiLCBcImVycm9yXCIsIFwiYWJvcnRcIl07XG5jb25zdCBtaWRkbGVob29rcyA9IFtcInByb2Nlc3NPcHRpb25zXCIsIFwidmFsaWRhdGVPcHRpb25zXCIsIFwiaW50ZXJjZXB0UmVxdWVzdFwiLCBcImZpbmFsaXplT3B0aW9uc1wiLCBcIm9uUmVxdWVzdFwiLCBcIm9uUmVzcG9uc2VcIiwgXCJvbkVycm9yXCIsIFwib25SZXR1cm5cIiwgXCJvbkhlYWRlcnNcIl07XG5mdW5jdGlvbiBjcmVhdGVSZXF1ZXN0ZXIoaW5pdE1pZGRsZXdhcmUsIGh0dHBSZXF1ZXN0KSB7XG4gIGNvbnN0IGxvYWRlZE1pZGRsZXdhcmUgPSBbXTtcbiAgY29uc3QgbWlkZGxld2FyZSA9IG1pZGRsZWhvb2tzLnJlZHVjZSgod2FyZSwgbmFtZSkgPT4ge1xuICAgIHdhcmVbbmFtZV0gPSB3YXJlW25hbWVdIHx8IFtdO1xuICAgIHJldHVybiB3YXJlO1xuICB9LCB7XG4gICAgcHJvY2Vzc09wdGlvbnM6IFtkZWZhdWx0T3B0aW9uc1ZhbGlkYXRvci5wcm9jZXNzT3B0aW9uc10sXG4gICAgdmFsaWRhdGVPcHRpb25zOiBbZGVmYXVsdE9wdGlvbnNWYWxpZGF0b3IudmFsaWRhdGVPcHRpb25zXVxuICB9KTtcbiAgZnVuY3Rpb24gcmVxdWVzdChvcHRzKSB7XG4gICAgY29uc3Qgb25SZXNwb25zZSA9IChyZXFFcnIsIHJlcywgY3R4KSA9PiB7XG4gICAgICBsZXQgZXJyb3IgPSByZXFFcnI7XG4gICAgICBsZXQgcmVzcG9uc2UgPSByZXM7XG4gICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzcG9uc2UgPSBhcHBseU1pZGRsZXdhcmUoXCJvblJlc3BvbnNlXCIsIHJlcywgY3R4KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmVzcG9uc2UgPSBudWxsO1xuICAgICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlcnJvciA9IGVycm9yICYmIGFwcGx5TWlkZGxld2FyZShcIm9uRXJyb3JcIiwgZXJyb3IsIGN0eCk7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY2hhbm5lbHMuZXJyb3IucHVibGlzaChlcnJvcik7XG4gICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgIGNoYW5uZWxzLnJlc3BvbnNlLnB1Ymxpc2gocmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY2hhbm5lbHMgPSBjaGFubmVsTmFtZXMucmVkdWNlKCh0YXJnZXQsIG5hbWUpID0+IHtcbiAgICAgIHRhcmdldFtuYW1lXSA9IGNyZWF0ZVB1YlN1YigpO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9LCB7fSk7XG4gICAgY29uc3QgYXBwbHlNaWRkbGV3YXJlID0gbWlkZGxld2FyZVJlZHVjZXIobWlkZGxld2FyZSk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGFwcGx5TWlkZGxld2FyZShcInByb2Nlc3NPcHRpb25zXCIsIG9wdHMpO1xuICAgIGFwcGx5TWlkZGxld2FyZShcInZhbGlkYXRlT3B0aW9uc1wiLCBvcHRpb25zKTtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgb3B0aW9ucyxcbiAgICAgIGNoYW5uZWxzLFxuICAgICAgYXBwbHlNaWRkbGV3YXJlXG4gICAgfTtcbiAgICBsZXQgb25nb2luZ1JlcXVlc3Q7XG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSBjaGFubmVscy5yZXF1ZXN0LnN1YnNjcmliZShjdHggPT4ge1xuICAgICAgb25nb2luZ1JlcXVlc3QgPSBodHRwUmVxdWVzdChjdHgsIChlcnIsIHJlcykgPT4gb25SZXNwb25zZShlcnIsIHJlcywgY3R4KSk7XG4gICAgfSk7XG4gICAgY2hhbm5lbHMuYWJvcnQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICBpZiAob25nb2luZ1JlcXVlc3QpIHtcbiAgICAgICAgb25nb2luZ1JlcXVlc3QuYWJvcnQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCByZXR1cm5WYWx1ZSA9IGFwcGx5TWlkZGxld2FyZShcIm9uUmV0dXJuXCIsIGNoYW5uZWxzLCBjb250ZXh0KTtcbiAgICBpZiAocmV0dXJuVmFsdWUgPT09IGNoYW5uZWxzKSB7XG4gICAgICBjaGFubmVscy5yZXF1ZXN0LnB1Ymxpc2goY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfVxuICByZXF1ZXN0LnVzZSA9IGZ1bmN0aW9uIHVzZShuZXdNaWRkbGV3YXJlKSB7XG4gICAgaWYgKCFuZXdNaWRkbGV3YXJlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmllZCB0byBhZGQgbWlkZGxld2FyZSB0aGF0IHJlc29sdmVkIHRvIGZhbHNleSB2YWx1ZVwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXdNaWRkbGV3YXJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyaWVkIHRvIGFkZCBtaWRkbGV3YXJlIHRoYXQgd2FzIGEgZnVuY3Rpb24uIEl0IHByb2JhYmx5IGV4cGVjdHMgeW91IHRvIHBhc3Mgb3B0aW9ucyB0byBpdC5cIik7XG4gICAgfVxuICAgIGlmIChuZXdNaWRkbGV3YXJlLm9uUmV0dXJuICYmIG1pZGRsZXdhcmUub25SZXR1cm4ubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJpZWQgdG8gYWRkIG5ldyBtaWRkbGV3YXJlIHdpdGggYG9uUmV0dXJuYCBoYW5kbGVyLCBidXQgYW5vdGhlciBoYW5kbGVyIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCBmb3IgdGhpcyBldmVudFwiKTtcbiAgICB9XG4gICAgbWlkZGxlaG9va3MuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKG5ld01pZGRsZXdhcmVba2V5XSkge1xuICAgICAgICBtaWRkbGV3YXJlW2tleV0ucHVzaChuZXdNaWRkbGV3YXJlW2tleV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxvYWRlZE1pZGRsZXdhcmUucHVzaChuZXdNaWRkbGV3YXJlKTtcbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfTtcbiAgcmVxdWVzdC5jbG9uZSA9ICgpID0+IGNyZWF0ZVJlcXVlc3Rlcihsb2FkZWRNaWRkbGV3YXJlLCBodHRwUmVxdWVzdCk7XG4gIGluaXRNaWRkbGV3YXJlLmZvckVhY2gocmVxdWVzdC51c2UpO1xuICByZXR1cm4gcmVxdWVzdDtcbn1cbmZ1bmN0aW9uIGxvd2VyQ2FzZUhlYWRlcnMoaGVhZGVycykge1xuICByZXR1cm4gT2JqZWN0LmtleXMoaGVhZGVycyB8fCB7fSkucmVkdWNlKChhY2MsIGhlYWRlcikgPT4ge1xuICAgIGFjY1toZWFkZXIudG9Mb3dlckNhc2UoKV0gPSBoZWFkZXJzW2hlYWRlcl07XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufVxuZnVuY3Rpb24gZm9ybWF0SG9zdG5hbWUoaG9zdG5hbWUpIHtcbiAgcmV0dXJuIGhvc3RuYW1lLnJlcGxhY2UoL15cXC4qLywgXCIuXCIpLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBwYXJzZU5vUHJveHlab25lKHpvbmVTdHIpIHtcbiAgY29uc3Qgem9uZSA9IHpvbmVTdHIudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IHpvbmVQYXJ0cyA9IHpvbmUuc3BsaXQoXCI6XCIsIDIpO1xuICBjb25zdCB6b25lSG9zdCA9IGZvcm1hdEhvc3RuYW1lKHpvbmVQYXJ0c1swXSk7XG4gIGNvbnN0IHpvbmVQb3J0ID0gem9uZVBhcnRzWzFdO1xuICBjb25zdCBoYXNQb3J0ID0gem9uZS5pbmRleE9mKFwiOlwiKSA+IC0xO1xuICByZXR1cm4ge1xuICAgIGhvc3RuYW1lOiB6b25lSG9zdCxcbiAgICBwb3J0OiB6b25lUG9ydCxcbiAgICBoYXNQb3J0XG4gIH07XG59XG5mdW5jdGlvbiB1cmlJbk5vUHJveHkodXJpLCBub1Byb3h5KSB7XG4gIGNvbnN0IHBvcnQgPSB1cmkucG9ydCB8fCAodXJpLnByb3RvY29sID09PSBcImh0dHBzOlwiID8gXCI0NDNcIiA6IFwiODBcIik7XG4gIGNvbnN0IGhvc3RuYW1lID0gZm9ybWF0SG9zdG5hbWUodXJpLmhvc3RuYW1lKTtcbiAgY29uc3Qgbm9Qcm94eUxpc3QgPSBub1Byb3h5LnNwbGl0KFwiLFwiKTtcbiAgcmV0dXJuIG5vUHJveHlMaXN0Lm1hcChwYXJzZU5vUHJveHlab25lKS5zb21lKG5vUHJveHlab25lID0+IHtcbiAgICBjb25zdCBpc01hdGNoZWRBdCA9IGhvc3RuYW1lLmluZGV4T2Yobm9Qcm94eVpvbmUuaG9zdG5hbWUpO1xuICAgIGNvbnN0IGhvc3RuYW1lTWF0Y2hlZCA9IGlzTWF0Y2hlZEF0ID4gLTEgJiYgaXNNYXRjaGVkQXQgPT09IGhvc3RuYW1lLmxlbmd0aCAtIG5vUHJveHlab25lLmhvc3RuYW1lLmxlbmd0aDtcbiAgICBpZiAobm9Qcm94eVpvbmUuaGFzUG9ydCkge1xuICAgICAgcmV0dXJuIHBvcnQgPT09IG5vUHJveHlab25lLnBvcnQgJiYgaG9zdG5hbWVNYXRjaGVkO1xuICAgIH1cbiAgICByZXR1cm4gaG9zdG5hbWVNYXRjaGVkO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFByb3h5RnJvbVVyaSh1cmkpIHtcbiAgY29uc3Qgbm9Qcm94eSA9IHByb2Nlc3MuZW52Lk5PX1BST1hZIHx8IHByb2Nlc3MuZW52Lm5vX3Byb3h5IHx8IFwiXCI7XG4gIGlmIChub1Byb3h5ID09PSBcIipcIikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChub1Byb3h5ICE9PSBcIlwiICYmIHVyaUluTm9Qcm94eSh1cmksIG5vUHJveHkpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHVyaS5wcm90b2NvbCA9PT0gXCJodHRwOlwiKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52LkhUVFBfUFJPWFkgfHwgcHJvY2Vzcy5lbnYuaHR0cF9wcm94eSB8fCBudWxsO1xuICB9XG4gIGlmICh1cmkucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuSFRUUFNfUFJPWFkgfHwgcHJvY2Vzcy5lbnYuaHR0cHNfcHJveHkgfHwgcHJvY2Vzcy5lbnYuSFRUUF9QUk9YWSB8fCBwcm9jZXNzLmVudi5odHRwX3Byb3h5IHx8IG51bGw7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRIb3N0RnJvbVVyaSh1cmkpIHtcbiAgbGV0IGhvc3QgPSB1cmkuaG9zdDtcbiAgaWYgKHVyaS5wb3J0KSB7XG4gICAgaWYgKHVyaS5wb3J0ID09PSBcIjgwXCIgJiYgdXJpLnByb3RvY29sID09PSBcImh0dHA6XCIgfHwgdXJpLnBvcnQgPT09IFwiNDQzXCIgJiYgdXJpLnByb3RvY29sID09PSBcImh0dHBzOlwiKSB7XG4gICAgICBob3N0ID0gdXJpLmhvc3RuYW1lO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaG9zdDtcbn1cbmZ1bmN0aW9uIGdldEhvc3RIZWFkZXJXaXRoUG9ydCh1cmkpIHtcbiAgY29uc3QgcG9ydCA9IHVyaS5wb3J0IHx8ICh1cmkucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIgPyBcIjQ0M1wiIDogXCI4MFwiKTtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KHVyaS5ob3N0bmFtZSwgXCI6XCIpLmNvbmNhdChwb3J0KTtcbn1cbmZ1bmN0aW9uIHJld3JpdGVVcmlGb3JQcm94eShyZXFPcHRzLCB1cmksIHByb3h5KSB7XG4gIGNvbnN0IGhlYWRlcnMgPSByZXFPcHRzLmhlYWRlcnMgfHwge307XG4gIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCByZXFPcHRzLCB7XG4gICAgaGVhZGVyc1xuICB9KTtcbiAgaGVhZGVycy5ob3N0ID0gaGVhZGVycy5ob3N0IHx8IGdldEhvc3RIZWFkZXJXaXRoUG9ydCh1cmkpO1xuICBvcHRpb25zLnByb3RvY29sID0gcHJveHkucHJvdG9jb2wgfHwgb3B0aW9ucy5wcm90b2NvbDtcbiAgb3B0aW9ucy5ob3N0bmFtZSA9IHByb3h5Lmhvc3QucmVwbGFjZSgvOlxcZCsvLCBcIlwiKTtcbiAgb3B0aW9ucy5wb3J0ID0gcHJveHkucG9ydDtcbiAgb3B0aW9ucy5ob3N0ID0gZ2V0SG9zdEZyb21VcmkoT2JqZWN0LmFzc2lnbih7fSwgdXJpLCBwcm94eSkpO1xuICBvcHRpb25zLmhyZWYgPSBcIlwiLmNvbmNhdChvcHRpb25zLnByb3RvY29sLCBcIi8vXCIpLmNvbmNhdChvcHRpb25zLmhvc3QpLmNvbmNhdChvcHRpb25zLnBhdGgpO1xuICBvcHRpb25zLnBhdGggPSB1cmxfX2RlZmF1bHQuZGVmYXVsdC5mb3JtYXQodXJpKTtcbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5mdW5jdGlvbiBnZXRQcm94eU9wdGlvbnMob3B0aW9ucykge1xuICBsZXQgcHJveHk7XG4gIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KFwicHJveHlcIikpIHtcbiAgICBwcm94eSA9IG9wdGlvbnMucHJveHk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdXJpID0gdXJsX19kZWZhdWx0LmRlZmF1bHQucGFyc2Uob3B0aW9ucy51cmwpO1xuICAgIHByb3h5ID0gZ2V0UHJveHlGcm9tVXJpKHVyaSk7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBwcm94eSA9PT0gXCJzdHJpbmdcIiA/IHVybF9fZGVmYXVsdC5kZWZhdWx0LnBhcnNlKHByb3h5KSA6IHByb3h5O1xufVxuXG4vKiEgc2ltcGxlLWNvbmNhdC4gTUlUIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuZnVuY3Rpb24gY29uY2F0KHN0cmVhbSwgY2IpIHtcbiAgY29uc3QgY2h1bmtzID0gW107XG4gIHN0cmVhbS5vbihcImRhdGFcIiwgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICB9KTtcbiAgc3RyZWFtLm9uY2UoXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYikgY2IobnVsbCwgQnVmZmVyLmNvbmNhdChjaHVua3MpKTtcbiAgICBjYiA9IG51bGw7XG4gIH0pO1xuICBzdHJlYW0ub25jZShcImVycm9yXCIsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoY2IpIGNiKGVycik7XG4gICAgY2IgPSBudWxsO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHRpbWVkT3V0KHJlcSwgdGltZSkge1xuICBpZiAocmVxLnRpbWVvdXRUaW1lcikge1xuICAgIHJldHVybiByZXE7XG4gIH1cbiAgY29uc3QgZGVsYXlzID0gaXNOYU4odGltZSkgPyB0aW1lIDoge1xuICAgIHNvY2tldDogdGltZSxcbiAgICBjb25uZWN0OiB0aW1lXG4gIH07XG4gIGNvbnN0IGhvc3RIZWFkZXIgPSByZXEuZ2V0SGVhZGVyKFwiaG9zdFwiKTtcbiAgY29uc3QgaG9zdCA9IGhvc3RIZWFkZXIgPyBcIiB0byBcIiArIGhvc3RIZWFkZXIgOiBcIlwiO1xuICBpZiAoZGVsYXlzLmNvbm5lY3QgIT09IHZvaWQgMCkge1xuICAgIHJlcS50aW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIHRpbWVvdXRIYW5kbGVyKCkge1xuICAgICAgcmVxLmFib3J0KCk7XG4gICAgICBjb25zdCBlID0gbmV3IEVycm9yKFwiQ29ubmVjdGlvbiB0aW1lZCBvdXQgb24gcmVxdWVzdFwiICsgaG9zdCk7XG4gICAgICBlLmNvZGUgPSBcIkVUSU1FRE9VVFwiO1xuICAgICAgcmVxLmVtaXQoXCJlcnJvclwiLCBlKTtcbiAgICB9LCBkZWxheXMuY29ubmVjdCk7XG4gIH1cbiAgcmVxLm9uKFwic29ja2V0XCIsIGZ1bmN0aW9uIGFzc2lnbihzb2NrZXQpIHtcbiAgICBpZiAoIShzb2NrZXQuY29ubmVjdGluZyB8fCBzb2NrZXQuX2Nvbm5lY3RpbmcpKSB7XG4gICAgICBjb25uZWN0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNvY2tldC5vbmNlKFwiY29ubmVjdFwiLCBjb25uZWN0KTtcbiAgfSk7XG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGlmIChyZXEudGltZW91dFRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQocmVxLnRpbWVvdXRUaW1lcik7XG4gICAgICByZXEudGltZW91dFRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY29ubmVjdCgpIHtcbiAgICBjbGVhcigpO1xuICAgIGlmIChkZWxheXMuc29ja2V0ICE9PSB2b2lkIDApIHtcbiAgICAgIHJlcS5zZXRUaW1lb3V0KGRlbGF5cy5zb2NrZXQsIGZ1bmN0aW9uIHNvY2tldFRpbWVvdXRIYW5kbGVyKCkge1xuICAgICAgICByZXEuYWJvcnQoKTtcbiAgICAgICAgY29uc3QgZSA9IG5ldyBFcnJvcihcIlNvY2tldCB0aW1lZCBvdXQgb24gcmVxdWVzdFwiICsgaG9zdCk7XG4gICAgICAgIGUuY29kZSA9IFwiRVNPQ0tFVFRJTUVET1VUXCI7XG4gICAgICAgIHJlcS5lbWl0KFwiZXJyb3JcIiwgZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcS5vbihcImVycm9yXCIsIGNsZWFyKTtcbn1cbmNvbnN0IHVyaVBhcnRzID0gW1wicHJvdG9jb2xcIiwgXCJzbGFzaGVzXCIsIFwiYXV0aFwiLCBcImhvc3RcIiwgXCJwb3J0XCIsIFwiaG9zdG5hbWVcIiwgXCJoYXNoXCIsIFwic2VhcmNoXCIsIFwicXVlcnlcIiwgXCJwYXRobmFtZVwiLCBcInBhdGhcIiwgXCJocmVmXCJdO1xuY29uc3QgZGVmYXVsdFByb3h5SGVhZGVyV2hpdGVMaXN0ID0gW1wiYWNjZXB0XCIsIFwiYWNjZXB0LWNoYXJzZXRcIiwgXCJhY2NlcHQtZW5jb2RpbmdcIiwgXCJhY2NlcHQtbGFuZ3VhZ2VcIiwgXCJhY2NlcHQtcmFuZ2VzXCIsIFwiY2FjaGUtY29udHJvbFwiLCBcImNvbnRlbnQtZW5jb2RpbmdcIiwgXCJjb250ZW50LWxhbmd1YWdlXCIsIFwiY29udGVudC1sb2NhdGlvblwiLCBcImNvbnRlbnQtbWQ1XCIsIFwiY29udGVudC1yYW5nZVwiLCBcImNvbnRlbnQtdHlwZVwiLCBcImNvbm5lY3Rpb25cIiwgXCJkYXRlXCIsIFwiZXhwZWN0XCIsIFwibWF4LWZvcndhcmRzXCIsIFwicHJhZ21hXCIsIFwicmVmZXJlclwiLCBcInRlXCIsIFwidXNlci1hZ2VudFwiLCBcInZpYVwiXTtcbmNvbnN0IGRlZmF1bHRQcm94eUhlYWRlckV4Y2x1c2l2ZUxpc3QgPSBbXCJwcm94eS1hdXRob3JpemF0aW9uXCJdO1xuZnVuY3Rpb24gc2hvdWxkRW5hYmxlKG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zLnR1bm5lbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBCb29sZWFuKG9wdGlvbnMudHVubmVsKTtcbiAgfVxuICBjb25zdCB1cmkgPSB1cmxfX2RlZmF1bHQuZGVmYXVsdC5wYXJzZShvcHRpb25zLnVybCk7XG4gIGlmICh1cmkucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBhcHBseUFnZW50KCkge1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIGxldCBwcm94eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0cyk7XG4gIGNvbnN0IHByb3h5SGVhZGVyV2hpdGVMaXN0ID0gZGVmYXVsdFByb3h5SGVhZGVyV2hpdGVMaXN0LmNvbmNhdChvcHRpb25zLnByb3h5SGVhZGVyV2hpdGVMaXN0IHx8IFtdKS5tYXAoaGVhZGVyID0+IGhlYWRlci50b0xvd2VyQ2FzZSgpKTtcbiAgY29uc3QgcHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0ID0gZGVmYXVsdFByb3h5SGVhZGVyRXhjbHVzaXZlTGlzdC5jb25jYXQob3B0aW9ucy5wcm94eUhlYWRlckV4Y2x1c2l2ZUxpc3QgfHwgW10pLm1hcChoZWFkZXIgPT4gaGVhZGVyLnRvTG93ZXJDYXNlKCkpO1xuICBjb25zdCBwcm94eUhlYWRlcnMgPSBnZXRBbGxvd2VkUHJveHlIZWFkZXJzKG9wdGlvbnMuaGVhZGVycywgcHJveHlIZWFkZXJXaGl0ZUxpc3QpO1xuICBwcm94eUhlYWRlcnMuaG9zdCA9IGNvbnN0cnVjdFByb3h5SG9zdChvcHRpb25zKTtcbiAgb3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmtleXMob3B0aW9ucy5oZWFkZXJzIHx8IHt9KS5yZWR1Y2UoKGhlYWRlcnMsIGhlYWRlcikgPT4ge1xuICAgIGNvbnN0IGlzQWxsb3dlZCA9IHByb3h5SGVhZGVyRXhjbHVzaXZlTGlzdC5pbmRleE9mKGhlYWRlci50b0xvd2VyQ2FzZSgpKSA9PT0gLTE7XG4gICAgaWYgKGlzQWxsb3dlZCkge1xuICAgICAgaGVhZGVyc1toZWFkZXJdID0gb3B0aW9ucy5oZWFkZXJzW2hlYWRlcl07XG4gICAgfVxuICAgIHJldHVybiBoZWFkZXJzO1xuICB9LCB7fSk7XG4gIGNvbnN0IHR1bm5lbEZuID0gZ2V0VHVubmVsRm4ob3B0aW9ucywgcHJveHkpO1xuICBjb25zdCB0dW5uZWxPcHRpb25zID0gY29uc3RydWN0VHVubmVsT3B0aW9ucyhvcHRpb25zLCBwcm94eSwgcHJveHlIZWFkZXJzKTtcbiAgb3B0aW9ucy5hZ2VudCA9IHR1bm5lbEZuKHR1bm5lbE9wdGlvbnMpO1xuICByZXR1cm4gb3B0aW9ucztcbn1cbmZ1bmN0aW9uIGdldFR1bm5lbEZuKG9wdGlvbnMsIHByb3h5KSB7XG4gIGNvbnN0IHVyaSA9IGdldFVyaVBhcnRzKG9wdGlvbnMpO1xuICBjb25zdCB0dW5uZWxGbk5hbWUgPSBjb25zdHJ1Y3RUdW5uZWxGbk5hbWUodXJpLCBwcm94eSk7XG4gIHJldHVybiB0dW5uZWxfX25hbWVzcGFjZVt0dW5uZWxGbk5hbWVdO1xufVxuZnVuY3Rpb24gZ2V0VXJpUGFydHMob3B0aW9ucykge1xuICByZXR1cm4gdXJpUGFydHMucmVkdWNlKCh1cmksIHBhcnQpID0+IHtcbiAgICB1cmlbcGFydF0gPSBvcHRpb25zW3BhcnRdO1xuICAgIHJldHVybiB1cmk7XG4gIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGNvbnN0cnVjdFR1bm5lbEZuTmFtZSh1cmksIHByb3h5KSB7XG4gIGNvbnN0IHVyaVByb3RvY29sID0gdXJpLnByb3RvY29sID09PSBcImh0dHBzOlwiID8gXCJodHRwc1wiIDogXCJodHRwXCI7XG4gIGNvbnN0IHByb3h5UHJvdG9jb2wgPSBwcm94eS5wcm90b2NvbCA9PT0gXCJodHRwczpcIiA/IFwiSHR0cHNcIiA6IFwiSHR0cFwiO1xuICByZXR1cm4gXCJcIi5jb25jYXQodXJpUHJvdG9jb2wsIFwiT3ZlclwiKS5jb25jYXQocHJveHlQcm90b2NvbCk7XG59XG5mdW5jdGlvbiBjb25zdHJ1Y3RQcm94eUhvc3QodXJpKSB7XG4gIGNvbnN0IHBvcnQgPSB1cmkucG9ydDtcbiAgY29uc3QgcHJvdG9jb2wgPSB1cmkucHJvdG9jb2w7XG4gIGxldCBwcm94eUhvc3QgPSBcIlwiLmNvbmNhdCh1cmkuaG9zdG5hbWUsIFwiOlwiKTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwcm94eUhvc3QgKz0gcG9ydDtcbiAgfSBlbHNlIGlmIChwcm90b2NvbCA9PT0gXCJodHRwczpcIikge1xuICAgIHByb3h5SG9zdCArPSBcIjQ0M1wiO1xuICB9IGVsc2Uge1xuICAgIHByb3h5SG9zdCArPSBcIjgwXCI7XG4gIH1cbiAgcmV0dXJuIHByb3h5SG9zdDtcbn1cbmZ1bmN0aW9uIGdldEFsbG93ZWRQcm94eUhlYWRlcnMoaGVhZGVycywgd2hpdGVMaXN0KSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhoZWFkZXJzKS5maWx0ZXIoaGVhZGVyID0+IHdoaXRlTGlzdC5pbmRleE9mKGhlYWRlci50b0xvd2VyQ2FzZSgpKSAhPT0gLTEpLnJlZHVjZSgoc2V0LCBoZWFkZXIpID0+IHtcbiAgICBzZXRbaGVhZGVyXSA9IGhlYWRlcnNbaGVhZGVyXTtcbiAgICByZXR1cm4gc2V0O1xuICB9LCB7fSk7XG59XG5mdW5jdGlvbiBjb25zdHJ1Y3RUdW5uZWxPcHRpb25zKG9wdGlvbnMsIHByb3h5LCBwcm94eUhlYWRlcnMpIHtcbiAgcmV0dXJuIHtcbiAgICBwcm94eToge1xuICAgICAgaG9zdDogcHJveHkuaG9zdG5hbWUsXG4gICAgICBwb3J0OiArcHJveHkucG9ydCxcbiAgICAgIHByb3h5QXV0aDogcHJveHkuYXV0aCxcbiAgICAgIGhlYWRlcnM6IHByb3h5SGVhZGVyc1xuICAgIH0sXG4gICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzLFxuICAgIGNhOiBvcHRpb25zLmNhLFxuICAgIGNlcnQ6IG9wdGlvbnMuY2VydCxcbiAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgIHBhc3NwaHJhc2U6IG9wdGlvbnMucGFzc3BocmFzZSxcbiAgICBwZng6IG9wdGlvbnMucGZ4LFxuICAgIGNpcGhlcnM6IG9wdGlvbnMuY2lwaGVycyxcbiAgICByZWplY3RVbmF1dGhvcml6ZWQ6IG9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkLFxuICAgIHNlY3VyZU9wdGlvbnM6IG9wdGlvbnMuc2VjdXJlT3B0aW9ucyxcbiAgICBzZWN1cmVQcm90b2NvbDogb3B0aW9ucy5zZWN1cmVQcm90b2NvbFxuICB9O1xufVxuY29uc3QgYWRhcHRlciA9IFwibm9kZVwiO1xuY29uc3QgcmVkdWNlUmVzcG9uc2UgPSAocmVzLCByZXFVcmwsIG1ldGhvZCwgYm9keSkgPT4gKHtcbiAgYm9keSxcbiAgdXJsOiByZXFVcmwsXG4gIG1ldGhvZCxcbiAgaGVhZGVyczogcmVzLmhlYWRlcnMsXG4gIHN0YXR1c0NvZGU6IHJlcy5zdGF0dXNDb2RlLFxuICBzdGF0dXNNZXNzYWdlOiByZXMuc3RhdHVzTWVzc2FnZVxufSk7XG5jb25zdCBodHRwUmVxdWVzdGVyID0gKGNvbnRleHQsIGNiKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBvcHRpb25zXG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB1cmkgPSBPYmplY3QuYXNzaWduKHt9LCB1cmxfX2RlZmF1bHQuZGVmYXVsdC5wYXJzZShvcHRpb25zLnVybCkpO1xuICBpZiAodHlwZW9mIGZldGNoID09PSBcImZ1bmN0aW9uXCIgJiYgb3B0aW9ucy5mZXRjaCkge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3QgcmVxT3B0czIgPSBjb250ZXh0LmFwcGx5TWlkZGxld2FyZShcImZpbmFsaXplT3B0aW9uc1wiLCB7XG4gICAgICAuLi51cmksXG4gICAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAuLi4odHlwZW9mIG9wdGlvbnMuZmV0Y2ggPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucy5mZXRjaC5oZWFkZXJzID8gbG93ZXJDYXNlSGVhZGVycyhvcHRpb25zLmZldGNoLmhlYWRlcnMpIDoge30pLFxuICAgICAgICAuLi5sb3dlckNhc2VIZWFkZXJzKG9wdGlvbnMuaGVhZGVycylcbiAgICAgIH0sXG4gICAgICBtYXhSZWRpcmVjdHM6IG9wdGlvbnMubWF4UmVkaXJlY3RzXG4gICAgfSk7XG4gICAgY29uc3QgZmV0Y2hPcHRzID0ge1xuICAgICAgY3JlZGVudGlhbHM6IG9wdGlvbnMud2l0aENyZWRlbnRpYWxzID8gXCJpbmNsdWRlXCIgOiBcIm9taXRcIixcbiAgICAgIC4uLih0eXBlb2Ygb3B0aW9ucy5mZXRjaCA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuZmV0Y2ggOiB7fSksXG4gICAgICBtZXRob2Q6IHJlcU9wdHMyLm1ldGhvZCxcbiAgICAgIGhlYWRlcnM6IHJlcU9wdHMyLmhlYWRlcnMsXG4gICAgICBib2R5OiBvcHRpb25zLmJvZHksXG4gICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsXG4gICAgfTtcbiAgICBjb25zdCBpbmplY3RlZFJlc3BvbnNlMiA9IGNvbnRleHQuYXBwbHlNaWRkbGV3YXJlKFwiaW50ZXJjZXB0UmVxdWVzdFwiLCB2b2lkIDAsIHtcbiAgICAgIGFkYXB0ZXIsXG4gICAgICBjb250ZXh0XG4gICAgfSk7XG4gICAgaWYgKGluamVjdGVkUmVzcG9uc2UyKSB7XG4gICAgICBjb25zdCBjYlRpbWVyID0gc2V0VGltZW91dChjYiwgMCwgbnVsbCwgaW5qZWN0ZWRSZXNwb25zZTIpO1xuICAgICAgY29uc3QgY2FuY2VsID0gKCkgPT4gY2xlYXJUaW1lb3V0KGNiVGltZXIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWJvcnQ6IGNhbmNlbFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdDIgPSBmZXRjaChvcHRpb25zLnVybCwgZmV0Y2hPcHRzKTtcbiAgICBjb250ZXh0LmFwcGx5TWlkZGxld2FyZShcIm9uUmVxdWVzdFwiLCB7XG4gICAgICBvcHRpb25zLFxuICAgICAgYWRhcHRlcixcbiAgICAgIHJlcXVlc3Q6IHJlcXVlc3QyLFxuICAgICAgY29udGV4dFxuICAgIH0pO1xuICAgIHJlcXVlc3QyLnRoZW4oYXN5bmMgcmVzID0+IHtcbiAgICAgIGNvbnN0IGJvZHkgPSBvcHRpb25zLnJhd0JvZHkgPyByZXMuYm9keSA6IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgICByZXMuaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgICBjYihudWxsLCB7XG4gICAgICAgIGJvZHksXG4gICAgICAgIHVybDogcmVzLnVybCxcbiAgICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzTWVzc2FnZTogcmVzLnN0YXR1c1RleHRcbiAgICAgIH0pO1xuICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICBpZiAoZXJyLm5hbWUgPT0gXCJBYm9ydEVycm9yXCIpIHJldHVybjtcbiAgICAgIGNiKGVycik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFib3J0OiAoKSA9PiBjb250cm9sbGVyLmFib3J0KClcbiAgICB9O1xuICB9XG4gIGNvbnN0IGJvZHlUeXBlID0gaXNTdHJlYW1fX2RlZmF1bHQuZGVmYXVsdChvcHRpb25zLmJvZHkpID8gXCJzdHJlYW1cIiA6IHR5cGVvZiBvcHRpb25zLmJvZHk7XG4gIGlmIChib2R5VHlwZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBib2R5VHlwZSAhPT0gXCJzdHJlYW1cIiAmJiBib2R5VHlwZSAhPT0gXCJzdHJpbmdcIiAmJiAhQnVmZmVyLmlzQnVmZmVyKG9wdGlvbnMuYm9keSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXF1ZXN0IGJvZHkgbXVzdCBiZSBhIHN0cmluZywgYnVmZmVyIG9yIHN0cmVhbSwgZ290IFwiLmNvbmNhdChib2R5VHlwZSkpO1xuICB9XG4gIGNvbnN0IGxlbmd0aEhlYWRlciA9IHt9O1xuICBpZiAob3B0aW9ucy5ib2R5U2l6ZSkge1xuICAgIGxlbmd0aEhlYWRlcltcImNvbnRlbnQtbGVuZ3RoXCJdID0gb3B0aW9ucy5ib2R5U2l6ZTtcbiAgfSBlbHNlIGlmIChvcHRpb25zLmJvZHkgJiYgYm9keVR5cGUgIT09IFwic3RyZWFtXCIpIHtcbiAgICBsZW5ndGhIZWFkZXJbXCJjb250ZW50LWxlbmd0aFwiXSA9IEJ1ZmZlci5ieXRlTGVuZ3RoKG9wdGlvbnMuYm9keSk7XG4gIH1cbiAgbGV0IGFib3J0ZWQgPSBmYWxzZTtcbiAgY29uc3QgY2FsbGJhY2sgPSAoZXJyLCByZXMpID0+ICFhYm9ydGVkICYmIGNiKGVyciwgcmVzKTtcbiAgY29udGV4dC5jaGFubmVscy5hYm9ydC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgIGFib3J0ZWQgPSB0cnVlO1xuICB9KTtcbiAgbGV0IHJlcU9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCB1cmksIHtcbiAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe30sIGxvd2VyQ2FzZUhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKSwgbGVuZ3RoSGVhZGVyKSxcbiAgICBtYXhSZWRpcmVjdHM6IG9wdGlvbnMubWF4UmVkaXJlY3RzXG4gIH0pO1xuICBjb25zdCBwcm94eSA9IGdldFByb3h5T3B0aW9ucyhvcHRpb25zKTtcbiAgY29uc3QgdHVubmVsID0gcHJveHkgJiYgc2hvdWxkRW5hYmxlKG9wdGlvbnMpO1xuICBjb25zdCBpbmplY3RlZFJlc3BvbnNlID0gY29udGV4dC5hcHBseU1pZGRsZXdhcmUoXCJpbnRlcmNlcHRSZXF1ZXN0XCIsIHZvaWQgMCwge1xuICAgIGFkYXB0ZXIsXG4gICAgY29udGV4dFxuICB9KTtcbiAgaWYgKGluamVjdGVkUmVzcG9uc2UpIHtcbiAgICBjb25zdCBjYlRpbWVyID0gc2V0SW1tZWRpYXRlKGNhbGxiYWNrLCBudWxsLCBpbmplY3RlZFJlc3BvbnNlKTtcbiAgICBjb25zdCBhYm9ydCA9ICgpID0+IGNsZWFySW1tZWRpYXRlKGNiVGltZXIpO1xuICAgIHJldHVybiB7XG4gICAgICBhYm9ydFxuICAgIH07XG4gIH1cbiAgaWYgKG9wdGlvbnMubWF4UmVkaXJlY3RzICE9PSAwKSB7XG4gICAgcmVxT3B0cy5tYXhSZWRpcmVjdHMgPSBvcHRpb25zLm1heFJlZGlyZWN0cyB8fCA1O1xuICB9XG4gIGlmIChwcm94eSAmJiB0dW5uZWwpIHtcbiAgICByZXFPcHRzID0gYXBwbHlBZ2VudChyZXFPcHRzLCBwcm94eSk7XG4gIH0gZWxzZSBpZiAocHJveHkgJiYgIXR1bm5lbCkge1xuICAgIHJlcU9wdHMgPSByZXdyaXRlVXJpRm9yUHJveHkocmVxT3B0cywgdXJpLCBwcm94eSk7XG4gIH1cbiAgaWYgKCF0dW5uZWwgJiYgcHJveHkgJiYgcHJveHkuYXV0aCAmJiAhcmVxT3B0cy5oZWFkZXJzW1wicHJveHktYXV0aG9yaXphdGlvblwiXSkge1xuICAgIGNvbnN0IFt1c2VybmFtZSwgcGFzc3dvcmRdID0gcHJveHkuYXV0aC51c2VybmFtZSA/IFtwcm94eS5hdXRoLnVzZXJuYW1lLCBwcm94eS5hdXRoLnBhc3N3b3JkXSA6IHByb3h5LmF1dGguc3BsaXQoXCI6XCIpLm1hcChpdGVtID0+IHFzX19kZWZhdWx0LmRlZmF1bHQudW5lc2NhcGUoaXRlbSkpO1xuICAgIGNvbnN0IGF1dGggPSBCdWZmZXIuZnJvbShcIlwiLmNvbmNhdCh1c2VybmFtZSwgXCI6XCIpLmNvbmNhdChwYXNzd29yZCksIFwidXRmOFwiKTtcbiAgICBjb25zdCBhdXRoQmFzZTY0ID0gYXV0aC50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICByZXFPcHRzLmhlYWRlcnNbXCJwcm94eS1hdXRob3JpemF0aW9uXCJdID0gXCJCYXNpYyBcIi5jb25jYXQoYXV0aEJhc2U2NCk7XG4gIH1cbiAgY29uc3QgdHJhbnNwb3J0ID0gZ2V0UmVxdWVzdFRyYW5zcG9ydChyZXFPcHRzLCBwcm94eSwgdHVubmVsKTtcbiAgaWYgKHR5cGVvZiBvcHRpb25zLmRlYnVnID09PSBcImZ1bmN0aW9uXCIgJiYgcHJveHkpIHtcbiAgICBvcHRpb25zLmRlYnVnKFwiUHJveHlpbmcgdXNpbmcgJXNcIiwgcmVxT3B0cy5hZ2VudCA/IFwidHVubmVsIGFnZW50XCIgOiBcIlwiLmNvbmNhdChyZXFPcHRzLmhvc3QsIFwiOlwiKS5jb25jYXQocmVxT3B0cy5wb3J0KSk7XG4gIH1cbiAgY29uc3QgdHJ5Q29tcHJlc3NlZCA9IHJlcU9wdHMubWV0aG9kICE9PSBcIkhFQURcIjtcbiAgaWYgKHRyeUNvbXByZXNzZWQgJiYgIXJlcU9wdHMuaGVhZGVyc1tcImFjY2VwdC1lbmNvZGluZ1wiXSAmJiBvcHRpb25zLmNvbXByZXNzICE9PSBmYWxzZSkge1xuICAgIHJlcU9wdHMuaGVhZGVyc1tcImFjY2VwdC1lbmNvZGluZ1wiXSA9IFwiYnIsIGd6aXAsIGRlZmxhdGVcIjtcbiAgfVxuICBjb25zdCBmaW5hbE9wdGlvbnMgPSBjb250ZXh0LmFwcGx5TWlkZGxld2FyZShcImZpbmFsaXplT3B0aW9uc1wiLCByZXFPcHRzKTtcbiAgY29uc3QgcmVxdWVzdCA9IHRyYW5zcG9ydC5yZXF1ZXN0KGZpbmFsT3B0aW9ucywgcmVzcG9uc2UgPT4ge1xuICAgIGNvbnN0IHJlcyA9IHRyeUNvbXByZXNzZWQgPyBkZWNvbXByZXNzUmVzcG9uc2VfX2RlZmF1bHQuZGVmYXVsdChyZXNwb25zZSkgOiByZXNwb25zZTtcbiAgICBjb25zdCByZXNTdHJlYW0gPSBjb250ZXh0LmFwcGx5TWlkZGxld2FyZShcIm9uSGVhZGVyc1wiLCByZXMsIHtcbiAgICAgIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICBhZGFwdGVyLFxuICAgICAgY29udGV4dFxuICAgIH0pO1xuICAgIGNvbnN0IHJlcVVybCA9IFwicmVzcG9uc2VVcmxcIiBpbiByZXNwb25zZSA/IHJlc3BvbnNlLnJlc3BvbnNlVXJsIDogb3B0aW9ucy51cmw7XG4gICAgaWYgKG9wdGlvbnMuc3RyZWFtKSB7XG4gICAgICBjYWxsYmFjayhudWxsLCByZWR1Y2VSZXNwb25zZShyZXMsIHJlcVVybCwgcmVxT3B0cy5tZXRob2QsIHJlc1N0cmVhbSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25jYXQocmVzU3RyZWFtLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgICAgY29uc3QgYm9keSA9IG9wdGlvbnMucmF3Qm9keSA/IGRhdGEgOiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICBjb25zdCByZWR1Y2VkID0gcmVkdWNlUmVzcG9uc2UocmVzLCByZXFVcmwsIHJlcU9wdHMubWV0aG9kLCBib2R5KTtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZWR1Y2VkKTtcbiAgICB9KTtcbiAgfSk7XG4gIGlmIChvcHRpb25zLnRpbWVvdXQpIHtcbiAgICB0aW1lZE91dChyZXF1ZXN0LCBvcHRpb25zLnRpbWVvdXQpO1xuICB9XG4gIHJlcXVlc3Qub25jZShcImVycm9yXCIsIGNhbGxiYWNrKTtcbiAgY29uc3Qge1xuICAgIGJvZHlTdHJlYW0sXG4gICAgcHJvZ3Jlc3NcbiAgfSA9IGdldFByb2dyZXNzU3RyZWFtKG9wdGlvbnMpO1xuICBjb250ZXh0LmFwcGx5TWlkZGxld2FyZShcIm9uUmVxdWVzdFwiLCB7XG4gICAgb3B0aW9ucyxcbiAgICBhZGFwdGVyLFxuICAgIHJlcXVlc3QsXG4gICAgY29udGV4dCxcbiAgICBwcm9ncmVzc1xuICB9KTtcbiAgaWYgKGJvZHlTdHJlYW0pIHtcbiAgICBib2R5U3RyZWFtLnBpcGUocmVxdWVzdCk7XG4gIH0gZWxzZSB7XG4gICAgcmVxdWVzdC5lbmQob3B0aW9ucy5ib2R5KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGFib3J0OiAoKSA9PiByZXF1ZXN0LmFib3J0KClcbiAgfTtcbn07XG5mdW5jdGlvbiBnZXRQcm9ncmVzc1N0cmVhbShvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucy5ib2R5KSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGNvbnN0IGJvZHlJc1N0cmVhbSA9IGlzU3RyZWFtX19kZWZhdWx0LmRlZmF1bHQob3B0aW9ucy5ib2R5KTtcbiAgY29uc3QgbGVuZ3RoID0gb3B0aW9ucy5ib2R5U2l6ZSB8fCAoYm9keUlzU3RyZWFtID8gbnVsbCA6IEJ1ZmZlci5ieXRlTGVuZ3RoKG9wdGlvbnMuYm9keSkpO1xuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybiBib2R5SXNTdHJlYW0gPyB7XG4gICAgICBib2R5U3RyZWFtOiBvcHRpb25zLmJvZHlcbiAgICB9IDoge307XG4gIH1cbiAgY29uc3QgcHJvZ3Jlc3MgPSBwcm9ncmVzc1N0cmVhbV9fZGVmYXVsdC5kZWZhdWx0KHtcbiAgICB0aW1lOiAxNixcbiAgICBsZW5ndGhcbiAgfSk7XG4gIGNvbnN0IGJvZHlTdHJlYW0gPSBib2R5SXNTdHJlYW0gPyBvcHRpb25zLmJvZHkgOiB0b1N0cmVhbV9fZGVmYXVsdC5kZWZhdWx0KG9wdGlvbnMuYm9keSk7XG4gIHJldHVybiB7XG4gICAgYm9keVN0cmVhbTogYm9keVN0cmVhbS5waXBlKHByb2dyZXNzKSxcbiAgICBwcm9ncmVzc1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0UmVxdWVzdFRyYW5zcG9ydChyZXFPcHRzLCBwcm94eSwgdHVubmVsKSB7XG4gIGNvbnN0IGlzSHR0cHNSZXF1ZXN0ID0gcmVxT3B0cy5wcm90b2NvbCA9PT0gXCJodHRwczpcIjtcbiAgY29uc3QgdHJhbnNwb3J0cyA9IHJlcU9wdHMubWF4UmVkaXJlY3RzID09PSAwID8ge1xuICAgIGh0dHA6IGh0dHBfX2RlZmF1bHQuZGVmYXVsdCxcbiAgICBodHRwczogaHR0cHNfX2RlZmF1bHQuZGVmYXVsdFxuICB9IDoge1xuICAgIGh0dHA6IGZvbGxvd19fZGVmYXVsdC5kZWZhdWx0Lmh0dHAsXG4gICAgaHR0cHM6IGZvbGxvd19fZGVmYXVsdC5kZWZhdWx0Lmh0dHBzXG4gIH07XG4gIGlmICghcHJveHkgfHwgdHVubmVsKSB7XG4gICAgcmV0dXJuIGlzSHR0cHNSZXF1ZXN0ID8gdHJhbnNwb3J0cy5odHRwcyA6IHRyYW5zcG9ydHMuaHR0cDtcbiAgfVxuICBsZXQgaXNIdHRwc1Byb3h5ID0gcHJveHkucG9ydCA9PT0gNDQzO1xuICBpZiAocHJveHkucHJvdG9jb2wpIHtcbiAgICBpc0h0dHBzUHJveHkgPSAvXmh0dHBzOj8vLnRlc3QocHJveHkucHJvdG9jb2wpO1xuICB9XG4gIHJldHVybiBpc0h0dHBzUHJveHkgPyB0cmFuc3BvcnRzLmh0dHBzIDogdHJhbnNwb3J0cy5odHRwO1xufVxuY29uc3QgZ2V0SXQgPSBmdW5jdGlvbiAoKSB7XG4gIGxldCBpbml0TWlkZGxld2FyZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gIGxldCBodHRwUmVxdWVzdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogaHR0cFJlcXVlc3RlcjtcbiAgcmV0dXJuIGNyZWF0ZVJlcXVlc3Rlcihpbml0TWlkZGxld2FyZSwgaHR0cFJlcXVlc3QpO1xufTtcbmNvbnN0IGVudmlyb25tZW50ID0gXCJub2RlXCI7XG5leHBvcnRzLmFkYXB0ZXIgPSBhZGFwdGVyO1xuZXhwb3J0cy5lbnZpcm9ubWVudCA9IGVudmlyb25tZW50O1xuZXhwb3J0cy5nZXRJdCA9IGdldEl0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguY2pzLm1hcFxuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdE9wdGlvbnNWYWxpZGF0b3IiLCJyZXF1aXJlIiwiZGVjb21wcmVzc1Jlc3BvbnNlIiwiZm9sbG93IiwiaHR0cCIsImh0dHBzIiwidG9TdHJlYW0iLCJpc1N0cmVhbSIsInByb2dyZXNzU3RyZWFtIiwicXMiLCJ1cmwiLCJ0dW5uZWwiLCJfaW50ZXJvcERlZmF1bHRDb21wYXQiLCJlIiwiZGVmYXVsdCIsIl9pbnRlcm9wTmFtZXNwYWNlQ29tcGF0IiwibiIsImNyZWF0ZSIsImtleXMiLCJmb3JFYWNoIiwiayIsImQiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXQiLCJlbnVtZXJhYmxlIiwiZnJlZXplIiwiZGVjb21wcmVzc1Jlc3BvbnNlX19kZWZhdWx0IiwiZm9sbG93X19kZWZhdWx0IiwiaHR0cF9fZGVmYXVsdCIsImh0dHBzX19kZWZhdWx0IiwidG9TdHJlYW1fX2RlZmF1bHQiLCJpc1N0cmVhbV9fZGVmYXVsdCIsInByb2dyZXNzU3RyZWFtX19kZWZhdWx0IiwicXNfX2RlZmF1bHQiLCJ1cmxfX2RlZmF1bHQiLCJ0dW5uZWxfX25hbWVzcGFjZSIsIm1pZGRsZXdhcmVSZWR1Y2VyIiwibWlkZGxld2FyZSIsImFwcGx5TWlkZGxld2FyZSIsImhvb2siLCJkZWZhdWx0VmFsdWUiLCJiYWlsRWFybHkiLCJfbGVuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiYXJncyIsIkFycmF5IiwiX2tleSIsImkiLCJoYW5kbGVyIiwiY3JlYXRlUHViU3ViIiwic3Vic2NyaWJlcnMiLCJuZXh0SWQiLCJzdWJzY3JpYmUiLCJzdWJzY3JpYmVyIiwiaWQiLCJ1bnN1YnNjcmliZSIsInB1Ymxpc2giLCJldmVudCIsImNoYW5uZWxOYW1lcyIsIm1pZGRsZWhvb2tzIiwiY3JlYXRlUmVxdWVzdGVyIiwiaW5pdE1pZGRsZXdhcmUiLCJodHRwUmVxdWVzdCIsImxvYWRlZE1pZGRsZXdhcmUiLCJyZWR1Y2UiLCJ3YXJlIiwibmFtZSIsInByb2Nlc3NPcHRpb25zIiwidmFsaWRhdGVPcHRpb25zIiwicmVxdWVzdCIsIm9wdHMiLCJvblJlc3BvbnNlIiwicmVxRXJyIiwicmVzIiwiY3R4IiwiZXJyb3IiLCJyZXNwb25zZSIsImVyciIsImNoYW5uZWxzIiwidGFyZ2V0Iiwib3B0aW9ucyIsImNvbnRleHQiLCJvbmdvaW5nUmVxdWVzdCIsImFib3J0IiwicmV0dXJuVmFsdWUiLCJ1c2UiLCJuZXdNaWRkbGV3YXJlIiwiRXJyb3IiLCJvblJldHVybiIsImtleSIsInB1c2giLCJjbG9uZSIsImxvd2VyQ2FzZUhlYWRlcnMiLCJoZWFkZXJzIiwiYWNjIiwiaGVhZGVyIiwidG9Mb3dlckNhc2UiLCJmb3JtYXRIb3N0bmFtZSIsImhvc3RuYW1lIiwicmVwbGFjZSIsInBhcnNlTm9Qcm94eVpvbmUiLCJ6b25lU3RyIiwiem9uZSIsInRyaW0iLCJ6b25lUGFydHMiLCJzcGxpdCIsInpvbmVIb3N0Iiwiem9uZVBvcnQiLCJoYXNQb3J0IiwiaW5kZXhPZiIsInBvcnQiLCJ1cmlJbk5vUHJveHkiLCJ1cmkiLCJub1Byb3h5IiwicHJvdG9jb2wiLCJub1Byb3h5TGlzdCIsIm1hcCIsInNvbWUiLCJub1Byb3h5Wm9uZSIsImlzTWF0Y2hlZEF0IiwiaG9zdG5hbWVNYXRjaGVkIiwiZ2V0UHJveHlGcm9tVXJpIiwicHJvY2VzcyIsImVudiIsIk5PX1BST1hZIiwibm9fcHJveHkiLCJIVFRQX1BST1hZIiwiaHR0cF9wcm94eSIsIkhUVFBTX1BST1hZIiwiaHR0cHNfcHJveHkiLCJnZXRIb3N0RnJvbVVyaSIsImhvc3QiLCJnZXRIb3N0SGVhZGVyV2l0aFBvcnQiLCJjb25jYXQiLCJyZXdyaXRlVXJpRm9yUHJveHkiLCJyZXFPcHRzIiwicHJveHkiLCJhc3NpZ24iLCJocmVmIiwicGF0aCIsImZvcm1hdCIsImdldFByb3h5T3B0aW9ucyIsImhhc093blByb3BlcnR5IiwicGFyc2UiLCJzdHJlYW0iLCJjYiIsImNodW5rcyIsIm9uIiwiY2h1bmsiLCJvbmNlIiwiQnVmZmVyIiwidGltZWRPdXQiLCJyZXEiLCJ0aW1lIiwidGltZW91dFRpbWVyIiwiZGVsYXlzIiwiaXNOYU4iLCJzb2NrZXQiLCJjb25uZWN0IiwiaG9zdEhlYWRlciIsImdldEhlYWRlciIsInNldFRpbWVvdXQiLCJ0aW1lb3V0SGFuZGxlciIsImNvZGUiLCJlbWl0IiwiY29ubmVjdGluZyIsIl9jb25uZWN0aW5nIiwiY2xlYXIiLCJjbGVhclRpbWVvdXQiLCJzb2NrZXRUaW1lb3V0SGFuZGxlciIsInVyaVBhcnRzIiwiZGVmYXVsdFByb3h5SGVhZGVyV2hpdGVMaXN0IiwiZGVmYXVsdFByb3h5SGVhZGVyRXhjbHVzaXZlTGlzdCIsInNob3VsZEVuYWJsZSIsIkJvb2xlYW4iLCJhcHBseUFnZW50IiwidW5kZWZpbmVkIiwicHJveHlIZWFkZXJXaGl0ZUxpc3QiLCJwcm94eUhlYWRlckV4Y2x1c2l2ZUxpc3QiLCJwcm94eUhlYWRlcnMiLCJnZXRBbGxvd2VkUHJveHlIZWFkZXJzIiwiY29uc3RydWN0UHJveHlIb3N0IiwiaXNBbGxvd2VkIiwidHVubmVsRm4iLCJnZXRUdW5uZWxGbiIsInR1bm5lbE9wdGlvbnMiLCJjb25zdHJ1Y3RUdW5uZWxPcHRpb25zIiwiYWdlbnQiLCJnZXRVcmlQYXJ0cyIsInR1bm5lbEZuTmFtZSIsImNvbnN0cnVjdFR1bm5lbEZuTmFtZSIsInBhcnQiLCJ1cmlQcm90b2NvbCIsInByb3h5UHJvdG9jb2wiLCJwcm94eUhvc3QiLCJ3aGl0ZUxpc3QiLCJmaWx0ZXIiLCJzZXQiLCJwcm94eUF1dGgiLCJhdXRoIiwiY2EiLCJjZXJ0IiwicGFzc3BocmFzZSIsInBmeCIsImNpcGhlcnMiLCJyZWplY3RVbmF1dGhvcml6ZWQiLCJzZWN1cmVPcHRpb25zIiwic2VjdXJlUHJvdG9jb2wiLCJhZGFwdGVyIiwicmVkdWNlUmVzcG9uc2UiLCJyZXFVcmwiLCJtZXRob2QiLCJib2R5Iiwic3RhdHVzQ29kZSIsInN0YXR1c01lc3NhZ2UiLCJodHRwUmVxdWVzdGVyIiwiZmV0Y2giLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwicmVxT3B0czIiLCJtYXhSZWRpcmVjdHMiLCJmZXRjaE9wdHMiLCJjcmVkZW50aWFscyIsIndpdGhDcmVkZW50aWFscyIsInNpZ25hbCIsImluamVjdGVkUmVzcG9uc2UyIiwiY2JUaW1lciIsImNhbmNlbCIsInJlcXVlc3QyIiwidGhlbiIsInJhd0JvZHkiLCJ0ZXh0Iiwic3RhdHVzIiwic3RhdHVzVGV4dCIsImNhdGNoIiwiYm9keVR5cGUiLCJpc0J1ZmZlciIsImxlbmd0aEhlYWRlciIsImJvZHlTaXplIiwiYnl0ZUxlbmd0aCIsImFib3J0ZWQiLCJjYWxsYmFjayIsImluamVjdGVkUmVzcG9uc2UiLCJzZXRJbW1lZGlhdGUiLCJjbGVhckltbWVkaWF0ZSIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJpdGVtIiwidW5lc2NhcGUiLCJmcm9tIiwiYXV0aEJhc2U2NCIsInRvU3RyaW5nIiwidHJhbnNwb3J0IiwiZ2V0UmVxdWVzdFRyYW5zcG9ydCIsImRlYnVnIiwidHJ5Q29tcHJlc3NlZCIsImNvbXByZXNzIiwiZmluYWxPcHRpb25zIiwicmVzU3RyZWFtIiwicmVzcG9uc2VVcmwiLCJkYXRhIiwicmVkdWNlZCIsInRpbWVvdXQiLCJib2R5U3RyZWFtIiwicHJvZ3Jlc3MiLCJnZXRQcm9ncmVzc1N0cmVhbSIsInBpcGUiLCJlbmQiLCJib2R5SXNTdHJlYW0iLCJpc0h0dHBzUmVxdWVzdCIsInRyYW5zcG9ydHMiLCJpc0h0dHBzUHJveHkiLCJ0ZXN0IiwiZ2V0SXQiLCJlbnZpcm9ubWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/get-it/dist/index.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/get-it/dist/middleware.cjs":
/*!*************************************************!*\
  !*** ./node_modules/get-it/dist/middleware.cjs ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar http = __webpack_require__(/*! http */ \"http\");\nvar https = __webpack_require__(/*! https */ \"https\");\nvar debugIt = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\");\nvar defaultOptionsValidator = __webpack_require__(/*! ./_chunks/defaultOptionsValidator-2bJolbLg.cjs */ \"(ssr)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-2bJolbLg.cjs\");\nvar isPlainObject = __webpack_require__(/*! is-plain-object */ \"(ssr)/./node_modules/is-plain-object/dist/is-plain-object.js\");\nvar progressStream = __webpack_require__(/*! progress-stream */ \"(ssr)/./node_modules/progress-stream/index.js\");\nvar allowed = __webpack_require__(/*! is-retry-allowed */ \"(ssr)/./node_modules/is-retry-allowed/index.js\");\nfunction _interopDefaultCompat(e) {\n    return e && typeof e === \"object\" && \"default\" in e ? e : {\n        default: e\n    };\n}\nvar debugIt__default = /*#__PURE__*/ _interopDefaultCompat(debugIt);\nvar progressStream__default = /*#__PURE__*/ _interopDefaultCompat(progressStream);\nvar allowed__default = /*#__PURE__*/ _interopDefaultCompat(allowed);\nconst isHttpsProto = /^https:/i;\nfunction agent(opts) {\n    const httpAgent = new http.Agent(opts);\n    const httpsAgent = new https.Agent(opts);\n    const agents = {\n        http: httpAgent,\n        https: httpsAgent\n    };\n    return {\n        finalizeOptions: (options)=>{\n            if (options.agent) {\n                return options;\n            }\n            if (options.maxRedirects > 0) {\n                return {\n                    ...options,\n                    agents\n                };\n            }\n            const isHttps = isHttpsProto.test(options.href || options.protocol);\n            return {\n                ...options,\n                agent: isHttps ? httpsAgent : httpAgent\n            };\n        }\n    };\n}\nconst leadingSlash = /^\\//;\nconst trailingSlash = /\\/$/;\nfunction base(baseUrl) {\n    const baseUri = baseUrl.replace(trailingSlash, \"\");\n    return {\n        processOptions: (options)=>{\n            if (/^https?:\\/\\//i.test(options.url)) {\n                return options;\n            }\n            const url = [\n                baseUri,\n                options.url.replace(leadingSlash, \"\")\n            ].join(\"/\");\n            return Object.assign({}, options, {\n                url\n            });\n        }\n    };\n}\nconst SENSITIVE_HEADERS = [\n    \"cookie\",\n    \"authorization\"\n];\nconst hasOwn = Object.prototype.hasOwnProperty;\nconst redactKeys = (source, redacted)=>{\n    const target = {};\n    for(const key in source){\n        if (hasOwn.call(source, key)) {\n            target[key] = redacted.indexOf(key.toLowerCase()) > -1 ? \"<redacted>\" : source[key];\n        }\n    }\n    return target;\n};\nfunction debug() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const verbose = opts.verbose;\n    const namespace = opts.namespace || \"get-it\";\n    const defaultLogger = debugIt__default.default(namespace);\n    const log = opts.log || defaultLogger;\n    const shortCircuit = log === defaultLogger && !debugIt__default.default.enabled(namespace);\n    let requestId = 0;\n    return {\n        processOptions: (options)=>{\n            options.debug = log;\n            options.requestId = options.requestId || ++requestId;\n            return options;\n        },\n        onRequest: (event)=>{\n            if (shortCircuit || !event) {\n                return event;\n            }\n            const options = event.options;\n            log(\"[%s] HTTP %s %s\", options.requestId, options.method, options.url);\n            if (verbose && options.body && typeof options.body === \"string\") {\n                log(\"[%s] Request body: %s\", options.requestId, options.body);\n            }\n            if (verbose && options.headers) {\n                const headers = opts.redactSensitiveHeaders === false ? options.headers : redactKeys(options.headers, SENSITIVE_HEADERS);\n                log(\"[%s] Request headers: %s\", options.requestId, JSON.stringify(headers, null, 2));\n            }\n            return event;\n        },\n        onResponse: (res, context)=>{\n            if (shortCircuit || !res) {\n                return res;\n            }\n            const reqId = context.options.requestId;\n            log(\"[%s] Response code: %s %s\", reqId, res.statusCode, res.statusMessage);\n            if (verbose && res.body) {\n                log(\"[%s] Response body: %s\", reqId, stringifyBody(res));\n            }\n            return res;\n        },\n        onError: (err, context)=>{\n            const reqId = context.options.requestId;\n            if (!err) {\n                log(\"[%s] Error encountered, but handled by an earlier middleware\", reqId);\n                return err;\n            }\n            log(\"[%s] ERROR: %s\", reqId, err.message);\n            return err;\n        }\n    };\n}\nfunction stringifyBody(res) {\n    const contentType = (res.headers[\"content-type\"] || \"\").toLowerCase();\n    const isJson = contentType.indexOf(\"application/json\") !== -1;\n    return isJson ? tryFormat(res.body) : res.body;\n}\nfunction tryFormat(body) {\n    try {\n        const parsed = typeof body === \"string\" ? JSON.parse(body) : body;\n        return JSON.stringify(parsed, null, 2);\n    } catch (err) {\n        return body;\n    }\n}\nfunction headers(_headers) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return {\n        processOptions: (options)=>{\n            const existing = options.headers || {};\n            options.headers = opts.override ? Object.assign({}, existing, _headers) : Object.assign({}, _headers, existing);\n            return options;\n        }\n    };\n}\nclass HttpError extends Error {\n    constructor(res, ctx){\n        super();\n        const truncatedUrl = res.url.length > 400 ? \"\".concat(res.url.slice(0, 399), \"…\") : res.url;\n        let msg = \"\".concat(res.method, \"-request to \").concat(truncatedUrl, \" resulted in \");\n        msg += \"HTTP \".concat(res.statusCode, \" \").concat(res.statusMessage);\n        this.message = msg.trim();\n        this.response = res;\n        this.request = ctx.options;\n    }\n}\nfunction httpErrors() {\n    return {\n        onResponse: (res, ctx)=>{\n            const isHttpError = res.statusCode >= 400;\n            if (!isHttpError) {\n                return res;\n            }\n            throw new HttpError(res, ctx);\n        }\n    };\n}\nfunction injectResponse() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (typeof opts.inject !== \"function\") {\n        throw new Error(\"`injectResponse` middleware requires a `inject` function\");\n    }\n    const inject = function inject2(prevValue, event) {\n        const response = opts.inject(event, prevValue);\n        if (!response) {\n            return prevValue;\n        }\n        const options = event.context.options;\n        return {\n            body: \"\",\n            url: options.url,\n            method: options.method,\n            headers: {},\n            statusCode: 200,\n            statusMessage: \"OK\",\n            ...response\n        };\n    };\n    return {\n        interceptRequest: inject\n    };\n}\nconst isBuffer = typeof Buffer === \"undefined\" ? ()=>false : (obj)=>Buffer.isBuffer(obj);\nconst serializeTypes = [\n    \"boolean\",\n    \"string\",\n    \"number\"\n];\nfunction jsonRequest() {\n    return {\n        processOptions: (options)=>{\n            const body = options.body;\n            if (!body) {\n                return options;\n            }\n            const isStream = typeof body.pipe === \"function\";\n            const shouldSerialize = !isStream && !isBuffer(body) && (serializeTypes.indexOf(typeof body) !== -1 || Array.isArray(body) || isPlainObject.isPlainObject(body));\n            if (!shouldSerialize) {\n                return options;\n            }\n            return Object.assign({}, options, {\n                body: JSON.stringify(options.body),\n                headers: Object.assign({}, options.headers, {\n                    \"Content-Type\": \"application/json\"\n                })\n            });\n        }\n    };\n}\nfunction jsonResponse(opts) {\n    return {\n        onResponse: (response)=>{\n            const contentType = response.headers[\"content-type\"] || \"\";\n            const shouldDecode = opts && opts.force || contentType.indexOf(\"application/json\") !== -1;\n            if (!response.body || !contentType || !shouldDecode) {\n                return response;\n            }\n            return Object.assign({}, response, {\n                body: tryParse(response.body)\n            });\n        },\n        processOptions: (options)=>Object.assign({}, options, {\n                headers: Object.assign({\n                    Accept: \"application/json\"\n                }, options.headers)\n            })\n    };\n    function tryParse(body) {\n        try {\n            return JSON.parse(body);\n        } catch (err) {\n            err.message = \"Failed to parsed response body as JSON: \".concat(err.message);\n            throw err;\n        }\n    }\n}\nfunction isBrowserOptions(options) {\n    return typeof options === \"object\" && options !== null && !(\"protocol\" in options);\n}\nfunction mtls() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!config.ca) {\n        throw new Error('Required mtls option \"ca\" is missing');\n    }\n    if (!config.cert) {\n        throw new Error('Required mtls option \"cert\" is missing');\n    }\n    if (!config.key) {\n        throw new Error('Required mtls option \"key\" is missing');\n    }\n    return {\n        finalizeOptions: (options)=>{\n            if (isBrowserOptions(options)) {\n                return options;\n            }\n            const mtlsOpts = {\n                cert: config.cert,\n                key: config.key,\n                ca: config.ca\n            };\n            return Object.assign({}, options, mtlsOpts);\n        }\n    };\n}\nlet actualGlobal = {};\nif (typeof globalThis !== \"undefined\") {\n    actualGlobal = globalThis;\n} else if (false) {} else if (typeof global !== \"undefined\") {\n    actualGlobal = global;\n} else if (typeof self !== \"undefined\") {\n    actualGlobal = self;\n}\nvar global$1 = actualGlobal;\nfunction observable() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const Observable = // eslint-disable-next-line @typescript-eslint/no-explicit-any -- @TODO consider dropping checking for a global Observable since it's not on a standards track\n    opts.implementation || global$1.Observable;\n    if (!Observable) {\n        throw new Error(\"`Observable` is not available in global scope, and no implementation was passed\");\n    }\n    return {\n        onReturn: (channels, context)=>new Observable((observer)=>{\n                channels.error.subscribe((err)=>observer.error(err));\n                channels.progress.subscribe((event)=>observer.next(Object.assign({\n                        type: \"progress\"\n                    }, event)));\n                channels.response.subscribe((response)=>{\n                    observer.next(Object.assign({\n                        type: \"response\"\n                    }, response));\n                    observer.complete();\n                });\n                channels.request.publish(context);\n                return ()=>channels.abort.publish();\n            })\n    };\n}\nfunction normalizer(stage) {\n    return (prog)=>({\n            stage,\n            percent: prog.percentage,\n            total: prog.length,\n            loaded: prog.transferred,\n            lengthComputable: !(prog.length === 0 && prog.percentage === 0)\n        });\n}\nfunction progress() {\n    return {\n        onHeaders: (response, evt)=>{\n            const _progress = progressStream__default.default({\n                time: 16\n            });\n            const normalize = normalizer(\"download\");\n            const contentLength = response.headers[\"content-length\"];\n            const length = contentLength ? Number(contentLength) : 0;\n            if (!isNaN(length) && length > 0) {\n                _progress.setLength(length);\n            }\n            _progress.on(\"progress\", (prog)=>evt.context.channels.progress.publish(normalize(prog)));\n            return response.pipe(_progress);\n        },\n        onRequest: (evt)=>{\n            if (!evt.progress) {\n                return;\n            }\n            const normalize = normalizer(\"upload\");\n            evt.progress.on(\"progress\", (prog)=>evt.context.channels.progress.publish(normalize(prog)));\n        }\n    };\n}\nconst promise = function() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const PromiseImplementation = options.implementation || Promise;\n    if (!PromiseImplementation) {\n        throw new Error(\"`Promise` is not available in global scope, and no implementation was passed\");\n    }\n    return {\n        onReturn: (channels, context)=>new PromiseImplementation((resolve, reject)=>{\n                const cancel = context.options.cancelToken;\n                if (cancel) {\n                    cancel.promise.then((reason)=>{\n                        channels.abort.publish(reason);\n                        reject(reason);\n                    });\n                }\n                channels.error.subscribe(reject);\n                channels.response.subscribe((response)=>{\n                    resolve(options.onlyBody ? response.body : response);\n                });\n                setTimeout(()=>{\n                    try {\n                        channels.request.publish(context);\n                    } catch (err) {\n                        reject(err);\n                    }\n                }, 0);\n            })\n    };\n};\nclass Cancel {\n    constructor(message){\n        this.__CANCEL__ = true;\n        this.message = message;\n    }\n    toString() {\n        return \"Cancel\".concat(this.message ? \": \".concat(this.message) : \"\");\n    }\n}\nconst _CancelToken = class _CancelToken {\n    constructor(executor){\n        if (typeof executor !== \"function\") {\n            throw new TypeError(\"executor must be a function.\");\n        }\n        let resolvePromise = null;\n        this.promise = new Promise((resolve)=>{\n            resolvePromise = resolve;\n        });\n        executor((message)=>{\n            if (this.reason) {\n                return;\n            }\n            this.reason = new Cancel(message);\n            resolvePromise(this.reason);\n        });\n    }\n};\n_CancelToken.source = ()=>{\n    let cancel;\n    const token = new _CancelToken((can)=>{\n        cancel = can;\n    });\n    return {\n        token,\n        cancel\n    };\n};\nlet CancelToken = _CancelToken;\nconst isCancel = (value)=>!!(value && (value == null ? void 0 : value.__CANCEL__));\npromise.Cancel = Cancel;\npromise.CancelToken = CancelToken;\npromise.isCancel = isCancel;\nfunction proxy(_proxy) {\n    if (_proxy !== false && (!_proxy || !_proxy.host)) {\n        throw new Error(\"Proxy middleware takes an object of host, port and auth properties\");\n    }\n    return {\n        processOptions: (options)=>Object.assign({\n                proxy: _proxy\n            }, options)\n    };\n}\nvar defaultShouldRetry = (err, num, options)=>{\n    if (options.method !== \"GET\" && options.method !== \"HEAD\") {\n        return false;\n    }\n    if (err.response && err.response.statusCode) {\n        return false;\n    }\n    return allowed__default.default(err);\n};\nconst isStream = (stream)=>stream !== null && typeof stream === \"object\" && typeof stream.pipe === \"function\";\nvar sharedRetry = (opts)=>{\n    const maxRetries = opts.maxRetries || 5;\n    const retryDelay = opts.retryDelay || getRetryDelay;\n    const allowRetry = opts.shouldRetry;\n    return {\n        onError: (err, context)=>{\n            const options = context.options;\n            const max = options.maxRetries || maxRetries;\n            const shouldRetry = options.shouldRetry || allowRetry;\n            const attemptNumber = options.attemptNumber || 0;\n            if (isStream(options.body)) {\n                return err;\n            }\n            if (!shouldRetry(err, attemptNumber, options) || attemptNumber >= max) {\n                return err;\n            }\n            const newContext = Object.assign({}, context, {\n                options: Object.assign({}, options, {\n                    attemptNumber: attemptNumber + 1\n                })\n            });\n            setTimeout(()=>context.channels.request.publish(newContext), retryDelay(attemptNumber));\n            return null;\n        }\n    };\n};\nfunction getRetryDelay(attemptNum) {\n    return 100 * Math.pow(2, attemptNum) + Math.random() * 100;\n}\nconst retry = function() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return sharedRetry({\n        shouldRetry: defaultShouldRetry,\n        ...opts\n    });\n};\nretry.shouldRetry = defaultShouldRetry;\nfunction encode(data) {\n    const query = new URLSearchParams();\n    const nest = (name, _value)=>{\n        const value = _value instanceof Set ? Array.from(_value) : _value;\n        if (Array.isArray(value)) {\n            if (value.length) {\n                for(const index in value){\n                    nest(\"\".concat(name, \"[\").concat(index, \"]\"), value[index]);\n                }\n            } else {\n                query.append(\"\".concat(name, \"[]\"), \"\");\n            }\n        } else if (typeof value === \"object\" && value !== null) {\n            for (const [key, obj] of Object.entries(value)){\n                nest(\"\".concat(name, \"[\").concat(key, \"]\"), obj);\n            }\n        } else {\n            query.append(name, value);\n        }\n    };\n    for (const [key, value] of Object.entries(data)){\n        nest(key, value);\n    }\n    return query.toString();\n}\nfunction urlEncoded() {\n    return {\n        processOptions: (options)=>{\n            const body = options.body;\n            if (!body) {\n                return options;\n            }\n            const isStream = typeof body.pipe === \"function\";\n            const shouldSerialize = !isStream && !isBuffer(body) && isPlainObject.isPlainObject(body);\n            if (!shouldSerialize) {\n                return options;\n            }\n            return {\n                ...options,\n                body: encode(options.body),\n                headers: {\n                    ...options.headers,\n                    \"Content-Type\": \"application/x-www-form-urlencoded\"\n                }\n            };\n        }\n    };\n}\nfunction buildKeepAlive(agent) {\n    return function keepAlive() {\n        let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        const ms = config.ms || 1e3;\n        const maxFree = config.maxFree || 256;\n        const agentOptions = {\n            keepAlive: true,\n            keepAliveMsecs: ms,\n            maxFreeSockets: maxFree\n        };\n        return agent(agentOptions);\n    };\n}\nconst keepAlive = buildKeepAlive(agent);\nexports.processOptions = defaultOptionsValidator.processOptions;\nexports.validateOptions = defaultOptionsValidator.validateOptions;\nexports.Cancel = Cancel;\nexports.CancelToken = CancelToken;\nexports.agent = agent;\nexports.base = base;\nexports.debug = debug;\nexports.headers = headers;\nexports.httpErrors = httpErrors;\nexports.injectResponse = injectResponse;\nexports.jsonRequest = jsonRequest;\nexports.jsonResponse = jsonResponse;\nexports.keepAlive = keepAlive;\nexports.mtls = mtls;\nexports.observable = observable;\nexports.progress = progress;\nexports.promise = promise;\nexports.proxy = proxy;\nexports.retry = retry;\nexports.urlEncoded = urlEncoded; //# sourceMappingURL=middleware.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvbWlkZGxld2FyZS5janMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0YsSUFBSUMsT0FBT0MsbUJBQU9BLENBQUM7QUFDbkIsSUFBSUMsUUFBUUQsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUUsVUFBVUYsbUJBQU9BLENBQUM7QUFDdEIsSUFBSUcsMEJBQTBCSCxtQkFBT0EsQ0FBQztBQUN0QyxJQUFJSSxnQkFBZ0JKLG1CQUFPQSxDQUFDO0FBQzVCLElBQUlLLGlCQUFpQkwsbUJBQU9BLENBQUM7QUFDN0IsSUFBSU0sVUFBVU4sbUJBQU9BLENBQUM7QUFDdEIsU0FBU08sc0JBQXNCQyxDQUFDO0lBQzlCLE9BQU9BLEtBQUssT0FBT0EsTUFBTSxZQUFZLGFBQWFBLElBQUlBLElBQUk7UUFDeERDLFNBQVNEO0lBQ1g7QUFDRjtBQUNBLElBQUlFLG1CQUFtQixXQUFXLEdBQUVILHNCQUFzQkw7QUFDMUQsSUFBSVMsMEJBQTBCLFdBQVcsR0FBRUosc0JBQXNCRjtBQUNqRSxJQUFJTyxtQkFBbUIsV0FBVyxHQUFFTCxzQkFBc0JEO0FBQzFELE1BQU1PLGVBQWU7QUFDckIsU0FBU0MsTUFBTUMsSUFBSTtJQUNqQixNQUFNQyxZQUFZLElBQUlqQixLQUFLa0IsS0FBSyxDQUFDRjtJQUNqQyxNQUFNRyxhQUFhLElBQUlqQixNQUFNZ0IsS0FBSyxDQUFDRjtJQUNuQyxNQUFNSSxTQUFTO1FBQ2JwQixNQUFNaUI7UUFDTmYsT0FBT2lCO0lBQ1Q7SUFDQSxPQUFPO1FBQ0xFLGlCQUFpQkMsQ0FBQUE7WUFDZixJQUFJQSxRQUFRUCxLQUFLLEVBQUU7Z0JBQ2pCLE9BQU9PO1lBQ1Q7WUFDQSxJQUFJQSxRQUFRQyxZQUFZLEdBQUcsR0FBRztnQkFDNUIsT0FBTztvQkFDTCxHQUFHRCxPQUFPO29CQUNWRjtnQkFDRjtZQUNGO1lBQ0EsTUFBTUksVUFBVVYsYUFB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Q2xCdkssYUFBYSxHQUFHNkw7QUFDaEI3TCxhQUFhLEdBQUdnTjtBQUNoQmhOLGtCQUFrQixHQUFHNk4sWUFDckIsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLWNvbW1lcmNlLXl0LWJ5LW1pa2UvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvbWlkZGxld2FyZS5janM/MGVhNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG52YXIgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xudmFyIGRlYnVnSXQgPSByZXF1aXJlKCdkZWJ1ZycpO1xudmFyIGRlZmF1bHRPcHRpb25zVmFsaWRhdG9yID0gcmVxdWlyZSgnLi9fY2h1bmtzL2RlZmF1bHRPcHRpb25zVmFsaWRhdG9yLTJiSm9sYkxnLmNqcycpO1xudmFyIGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCdpcy1wbGFpbi1vYmplY3QnKTtcbnZhciBwcm9ncmVzc1N0cmVhbSA9IHJlcXVpcmUoJ3Byb2dyZXNzLXN0cmVhbScpO1xudmFyIGFsbG93ZWQgPSByZXF1aXJlKCdpcy1yZXRyeS1hbGxvd2VkJyk7XG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHRDb21wYXQoZSkge1xuICByZXR1cm4gZSAmJiB0eXBlb2YgZSA9PT0gJ29iamVjdCcgJiYgJ2RlZmF1bHQnIGluIGUgPyBlIDoge1xuICAgIGRlZmF1bHQ6IGVcbiAgfTtcbn1cbnZhciBkZWJ1Z0l0X19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdENvbXBhdChkZWJ1Z0l0KTtcbnZhciBwcm9ncmVzc1N0cmVhbV9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRDb21wYXQocHJvZ3Jlc3NTdHJlYW0pO1xudmFyIGFsbG93ZWRfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0Q29tcGF0KGFsbG93ZWQpO1xuY29uc3QgaXNIdHRwc1Byb3RvID0gL15odHRwczovaTtcbmZ1bmN0aW9uIGFnZW50KG9wdHMpIHtcbiAgY29uc3QgaHR0cEFnZW50ID0gbmV3IGh0dHAuQWdlbnQob3B0cyk7XG4gIGNvbnN0IGh0dHBzQWdlbnQgPSBuZXcgaHR0cHMuQWdlbnQob3B0cyk7XG4gIGNvbnN0IGFnZW50cyA9IHtcbiAgICBodHRwOiBodHRwQWdlbnQsXG4gICAgaHR0cHM6IGh0dHBzQWdlbnRcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBmaW5hbGl6ZU9wdGlvbnM6IG9wdGlvbnMgPT4ge1xuICAgICAgaWYgKG9wdGlvbnMuYWdlbnQpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5tYXhSZWRpcmVjdHMgPiAwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICBhZ2VudHNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzSHR0cHMgPSBpc0h0dHBzUHJvdG8udGVzdChvcHRpb25zLmhyZWYgfHwgb3B0aW9ucy5wcm90b2NvbCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBhZ2VudDogaXNIdHRwcyA/IGh0dHBzQWdlbnQgOiBodHRwQWdlbnRcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuY29uc3QgbGVhZGluZ1NsYXNoID0gL15cXC8vO1xuY29uc3QgdHJhaWxpbmdTbGFzaCA9IC9cXC8kLztcbmZ1bmN0aW9uIGJhc2UoYmFzZVVybCkge1xuICBjb25zdCBiYXNlVXJpID0gYmFzZVVybC5yZXBsYWNlKHRyYWlsaW5nU2xhc2gsIFwiXCIpO1xuICByZXR1cm4ge1xuICAgIHByb2Nlc3NPcHRpb25zOiBvcHRpb25zID0+IHtcbiAgICAgIGlmICgvXmh0dHBzPzpcXC9cXC8vaS50ZXN0KG9wdGlvbnMudXJsKSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHVybCA9IFtiYXNlVXJpLCBvcHRpb25zLnVybC5yZXBsYWNlKGxlYWRpbmdTbGFzaCwgXCJcIildLmpvaW4oXCIvXCIpO1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgdXJsXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBTRU5TSVRJVkVfSEVBREVSUyA9IFtcImNvb2tpZVwiLCBcImF1dGhvcml6YXRpb25cIl07XG5jb25zdCBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuY29uc3QgcmVkYWN0S2V5cyA9IChzb3VyY2UsIHJlZGFjdGVkKSA9PiB7XG4gIGNvbnN0IHRhcmdldCA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UpIHtcbiAgICBpZiAoaGFzT3duLmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IHJlZGFjdGVkLmluZGV4T2Yoa2V5LnRvTG93ZXJDYXNlKCkpID4gLTEgPyBcIjxyZWRhY3RlZD5cIiA6IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbmZ1bmN0aW9uIGRlYnVnKCkge1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIGNvbnN0IHZlcmJvc2UgPSBvcHRzLnZlcmJvc2U7XG4gIGNvbnN0IG5hbWVzcGFjZSA9IG9wdHMubmFtZXNwYWNlIHx8IFwiZ2V0LWl0XCI7XG4gIGNvbnN0IGRlZmF1bHRMb2dnZXIgPSBkZWJ1Z0l0X19kZWZhdWx0LmRlZmF1bHQobmFtZXNwYWNlKTtcbiAgY29uc3QgbG9nID0gb3B0cy5sb2cgfHwgZGVmYXVsdExvZ2dlcjtcbiAgY29uc3Qgc2hvcnRDaXJjdWl0ID0gbG9nID09PSBkZWZhdWx0TG9nZ2VyICYmICFkZWJ1Z0l0X19kZWZhdWx0LmRlZmF1bHQuZW5hYmxlZChuYW1lc3BhY2UpO1xuICBsZXQgcmVxdWVzdElkID0gMDtcbiAgcmV0dXJuIHtcbiAgICBwcm9jZXNzT3B0aW9uczogb3B0aW9ucyA9PiB7XG4gICAgICBvcHRpb25zLmRlYnVnID0gbG9nO1xuICAgICAgb3B0aW9ucy5yZXF1ZXN0SWQgPSBvcHRpb25zLnJlcXVlc3RJZCB8fCArK3JlcXVlc3RJZDtcbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH0sXG4gICAgb25SZXF1ZXN0OiBldmVudCA9PiB7XG4gICAgICBpZiAoc2hvcnRDaXJjdWl0IHx8ICFldmVudCkge1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG4gICAgICBjb25zdCBvcHRpb25zID0gZXZlbnQub3B0aW9ucztcbiAgICAgIGxvZyhcIlslc10gSFRUUCAlcyAlc1wiLCBvcHRpb25zLnJlcXVlc3RJZCwgb3B0aW9ucy5tZXRob2QsIG9wdGlvbnMudXJsKTtcbiAgICAgIGlmICh2ZXJib3NlICYmIG9wdGlvbnMuYm9keSAmJiB0eXBlb2Ygb3B0aW9ucy5ib2R5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGxvZyhcIlslc10gUmVxdWVzdCBib2R5OiAlc1wiLCBvcHRpb25zLnJlcXVlc3RJZCwgb3B0aW9ucy5ib2R5KTtcbiAgICAgIH1cbiAgICAgIGlmICh2ZXJib3NlICYmIG9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gb3B0cy5yZWRhY3RTZW5zaXRpdmVIZWFkZXJzID09PSBmYWxzZSA/IG9wdGlvbnMuaGVhZGVycyA6IHJlZGFjdEtleXMob3B0aW9ucy5oZWFkZXJzLCBTRU5TSVRJVkVfSEVBREVSUyk7XG4gICAgICAgIGxvZyhcIlslc10gUmVxdWVzdCBoZWFkZXJzOiAlc1wiLCBvcHRpb25zLnJlcXVlc3RJZCwgSlNPTi5zdHJpbmdpZnkoaGVhZGVycywgbnVsbCwgMikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH0sXG4gICAgb25SZXNwb25zZTogKHJlcywgY29udGV4dCkgPT4ge1xuICAgICAgaWYgKHNob3J0Q2lyY3VpdCB8fCAhcmVzKSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgICBjb25zdCByZXFJZCA9IGNvbnRleHQub3B0aW9ucy5yZXF1ZXN0SWQ7XG4gICAgICBsb2coXCJbJXNdIFJlc3BvbnNlIGNvZGU6ICVzICVzXCIsIHJlcUlkLCByZXMuc3RhdHVzQ29kZSwgcmVzLnN0YXR1c01lc3NhZ2UpO1xuICAgICAgaWYgKHZlcmJvc2UgJiYgcmVzLmJvZHkpIHtcbiAgICAgICAgbG9nKFwiWyVzXSBSZXNwb25zZSBib2R5OiAlc1wiLCByZXFJZCwgc3RyaW5naWZ5Qm9keShyZXMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICBvbkVycm9yOiAoZXJyLCBjb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCByZXFJZCA9IGNvbnRleHQub3B0aW9ucy5yZXF1ZXN0SWQ7XG4gICAgICBpZiAoIWVycikge1xuICAgICAgICBsb2coXCJbJXNdIEVycm9yIGVuY291bnRlcmVkLCBidXQgaGFuZGxlZCBieSBhbiBlYXJsaWVyIG1pZGRsZXdhcmVcIiwgcmVxSWQpO1xuICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgfVxuICAgICAgbG9nKFwiWyVzXSBFUlJPUjogJXNcIiwgcmVxSWQsIGVyci5tZXNzYWdlKTtcbiAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5Qm9keShyZXMpIHtcbiAgY29uc3QgY29udGVudFR5cGUgPSAocmVzLmhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgY29uc3QgaXNKc29uID0gY29udGVudFR5cGUuaW5kZXhPZihcImFwcGxpY2F0aW9uL2pzb25cIikgIT09IC0xO1xuICByZXR1cm4gaXNKc29uID8gdHJ5Rm9ybWF0KHJlcy5ib2R5KSA6IHJlcy5ib2R5O1xufVxuZnVuY3Rpb24gdHJ5Rm9ybWF0KGJvZHkpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwYXJzZWQgPSB0eXBlb2YgYm9keSA9PT0gXCJzdHJpbmdcIiA/IEpTT04ucGFyc2UoYm9keSkgOiBib2R5O1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXJzZWQsIG51bGwsIDIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gYm9keTtcbiAgfVxufVxuZnVuY3Rpb24gaGVhZGVycyhfaGVhZGVycykge1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHJldHVybiB7XG4gICAgcHJvY2Vzc09wdGlvbnM6IG9wdGlvbnMgPT4ge1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSBvcHRpb25zLmhlYWRlcnMgfHwge307XG4gICAgICBvcHRpb25zLmhlYWRlcnMgPSBvcHRzLm92ZXJyaWRlID8gT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcsIF9oZWFkZXJzKSA6IE9iamVjdC5hc3NpZ24oe30sIF9oZWFkZXJzLCBleGlzdGluZyk7XG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gIH07XG59XG5jbGFzcyBIdHRwRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHJlcywgY3R4KSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCB0cnVuY2F0ZWRVcmwgPSByZXMudXJsLmxlbmd0aCA+IDQwMCA/IFwiXCIuY29uY2F0KHJlcy51cmwuc2xpY2UoMCwgMzk5KSwgXCJcXHUyMDI2XCIpIDogcmVzLnVybDtcbiAgICBsZXQgbXNnID0gXCJcIi5jb25jYXQocmVzLm1ldGhvZCwgXCItcmVxdWVzdCB0byBcIikuY29uY2F0KHRydW5jYXRlZFVybCwgXCIgcmVzdWx0ZWQgaW4gXCIpO1xuICAgIG1zZyArPSBcIkhUVFAgXCIuY29uY2F0KHJlcy5zdGF0dXNDb2RlLCBcIiBcIikuY29uY2F0KHJlcy5zdGF0dXNNZXNzYWdlKTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtc2cudHJpbSgpO1xuICAgIHRoaXMucmVzcG9uc2UgPSByZXM7XG4gICAgdGhpcy5yZXF1ZXN0ID0gY3R4Lm9wdGlvbnM7XG4gIH1cbn1cbmZ1bmN0aW9uIGh0dHBFcnJvcnMoKSB7XG4gIHJldHVybiB7XG4gICAgb25SZXNwb25zZTogKHJlcywgY3R4KSA9PiB7XG4gICAgICBjb25zdCBpc0h0dHBFcnJvciA9IHJlcy5zdGF0dXNDb2RlID49IDQwMDtcbiAgICAgIGlmICghaXNIdHRwRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBIdHRwRXJyb3IocmVzLCBjdHgpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGluamVjdFJlc3BvbnNlKCkge1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIGlmICh0eXBlb2Ygb3B0cy5pbmplY3QgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImBpbmplY3RSZXNwb25zZWAgbWlkZGxld2FyZSByZXF1aXJlcyBhIGBpbmplY3RgIGZ1bmN0aW9uXCIpO1xuICB9XG4gIGNvbnN0IGluamVjdCA9IGZ1bmN0aW9uIGluamVjdDIocHJldlZhbHVlLCBldmVudCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gb3B0cy5pbmplY3QoZXZlbnQsIHByZXZWYWx1ZSk7XG4gICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgcmV0dXJuIHByZXZWYWx1ZTtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9ucyA9IGV2ZW50LmNvbnRleHQub3B0aW9ucztcbiAgICByZXR1cm4ge1xuICAgICAgYm9keTogXCJcIixcbiAgICAgIHVybDogb3B0aW9ucy51cmwsXG4gICAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuICAgICAgaGVhZGVyczoge30sXG4gICAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgICBzdGF0dXNNZXNzYWdlOiBcIk9LXCIsXG4gICAgICAuLi5yZXNwb25zZVxuICAgIH07XG4gIH07XG4gIHJldHVybiB7XG4gICAgaW50ZXJjZXB0UmVxdWVzdDogaW5qZWN0XG4gIH07XG59XG5jb25zdCBpc0J1ZmZlciA9IHR5cGVvZiBCdWZmZXIgPT09IFwidW5kZWZpbmVkXCIgPyAoKSA9PiBmYWxzZSA6IG9iaiA9PiBCdWZmZXIuaXNCdWZmZXIob2JqKTtcbmNvbnN0IHNlcmlhbGl6ZVR5cGVzID0gW1wiYm9vbGVhblwiLCBcInN0cmluZ1wiLCBcIm51bWJlclwiXTtcbmZ1bmN0aW9uIGpzb25SZXF1ZXN0KCkge1xuICByZXR1cm4ge1xuICAgIHByb2Nlc3NPcHRpb25zOiBvcHRpb25zID0+IHtcbiAgICAgIGNvbnN0IGJvZHkgPSBvcHRpb25zLmJvZHk7XG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICB9XG4gICAgICBjb25zdCBpc1N0cmVhbSA9IHR5cGVvZiBib2R5LnBpcGUgPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgIGNvbnN0IHNob3VsZFNlcmlhbGl6ZSA9ICFpc1N0cmVhbSAmJiAhaXNCdWZmZXIoYm9keSkgJiYgKHNlcmlhbGl6ZVR5cGVzLmluZGV4T2YodHlwZW9mIGJvZHkpICE9PSAtMSB8fCBBcnJheS5pc0FycmF5KGJvZHkpIHx8IGlzUGxhaW5PYmplY3QuaXNQbGFpbk9iamVjdChib2R5KSk7XG4gICAgICBpZiAoIXNob3VsZFNlcmlhbGl6ZSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgIH1cbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuYm9keSksXG4gICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMuaGVhZGVycywge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBqc29uUmVzcG9uc2Uob3B0cykge1xuICByZXR1cm4ge1xuICAgIG9uUmVzcG9uc2U6IHJlc3BvbnNlID0+IHtcbiAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSB8fCBcIlwiO1xuICAgICAgY29uc3Qgc2hvdWxkRGVjb2RlID0gb3B0cyAmJiBvcHRzLmZvcmNlIHx8IGNvbnRlbnRUeXBlLmluZGV4T2YoXCJhcHBsaWNhdGlvbi9qc29uXCIpICE9PSAtMTtcbiAgICAgIGlmICghcmVzcG9uc2UuYm9keSB8fCAhY29udGVudFR5cGUgfHwgIXNob3VsZERlY29kZSkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcmVzcG9uc2UsIHtcbiAgICAgICAgYm9keTogdHJ5UGFyc2UocmVzcG9uc2UuYm9keSlcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcHJvY2Vzc09wdGlvbnM6IG9wdGlvbnMgPT4gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgIH0sIG9wdGlvbnMuaGVhZGVycylcbiAgICB9KVxuICB9O1xuICBmdW5jdGlvbiB0cnlQYXJzZShib2R5KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGJvZHkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZXJyLm1lc3NhZ2UgPSBcIkZhaWxlZCB0byBwYXJzZWQgcmVzcG9uc2UgYm9keSBhcyBKU09OOiBcIi5jb25jYXQoZXJyLm1lc3NhZ2UpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaXNCcm93c2VyT3B0aW9ucyhvcHRpb25zKSB7XG4gIHJldHVybiB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zICE9PSBudWxsICYmICEoXCJwcm90b2NvbFwiIGluIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gbXRscygpIHtcbiAgbGV0IGNvbmZpZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIGlmICghY29uZmlnLmNhKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1aXJlZCBtdGxzIG9wdGlvbiBcImNhXCIgaXMgbWlzc2luZycpO1xuICB9XG4gIGlmICghY29uZmlnLmNlcnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVpcmVkIG10bHMgb3B0aW9uIFwiY2VydFwiIGlzIG1pc3NpbmcnKTtcbiAgfVxuICBpZiAoIWNvbmZpZy5rZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVpcmVkIG10bHMgb3B0aW9uIFwia2V5XCIgaXMgbWlzc2luZycpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZmluYWxpemVPcHRpb25zOiBvcHRpb25zID0+IHtcbiAgICAgIGlmIChpc0Jyb3dzZXJPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgfVxuICAgICAgY29uc3QgbXRsc09wdHMgPSB7XG4gICAgICAgIGNlcnQ6IGNvbmZpZy5jZXJ0LFxuICAgICAgICBrZXk6IGNvbmZpZy5rZXksXG4gICAgICAgIGNhOiBjb25maWcuY2FcbiAgICAgIH07XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgbXRsc09wdHMpO1xuICAgIH1cbiAgfTtcbn1cbmxldCBhY3R1YWxHbG9iYWwgPSB7fTtcbmlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICBhY3R1YWxHbG9iYWwgPSBnbG9iYWxUaGlzO1xufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIGFjdHVhbEdsb2JhbCA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICBhY3R1YWxHbG9iYWwgPSBnbG9iYWw7XG59IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIGFjdHVhbEdsb2JhbCA9IHNlbGY7XG59XG52YXIgZ2xvYmFsJDEgPSBhY3R1YWxHbG9iYWw7XG5mdW5jdGlvbiBvYnNlcnZhYmxlKCkge1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIGNvbnN0IE9ic2VydmFibGUgPVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAtLSBAVE9ETyBjb25zaWRlciBkcm9wcGluZyBjaGVja2luZyBmb3IgYSBnbG9iYWwgT2JzZXJ2YWJsZSBzaW5jZSBpdCdzIG5vdCBvbiBhIHN0YW5kYXJkcyB0cmFja1xuICBvcHRzLmltcGxlbWVudGF0aW9uIHx8IGdsb2JhbCQxLk9ic2VydmFibGU7XG4gIGlmICghT2JzZXJ2YWJsZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImBPYnNlcnZhYmxlYCBpcyBub3QgYXZhaWxhYmxlIGluIGdsb2JhbCBzY29wZSwgYW5kIG5vIGltcGxlbWVudGF0aW9uIHdhcyBwYXNzZWRcIik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBvblJldHVybjogKGNoYW5uZWxzLCBjb250ZXh0KSA9PiBuZXcgT2JzZXJ2YWJsZShvYnNlcnZlciA9PiB7XG4gICAgICBjaGFubmVscy5lcnJvci5zdWJzY3JpYmUoZXJyID0+IG9ic2VydmVyLmVycm9yKGVycikpO1xuICAgICAgY2hhbm5lbHMucHJvZ3Jlc3Muc3Vic2NyaWJlKGV2ZW50ID0+IG9ic2VydmVyLm5leHQoT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIHR5cGU6IFwicHJvZ3Jlc3NcIlxuICAgICAgfSwgZXZlbnQpKSk7XG4gICAgICBjaGFubmVscy5yZXNwb25zZS5zdWJzY3JpYmUocmVzcG9uc2UgPT4ge1xuICAgICAgICBvYnNlcnZlci5uZXh0KE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIHR5cGU6IFwicmVzcG9uc2VcIlxuICAgICAgICB9LCByZXNwb25zZSkpO1xuICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgfSk7XG4gICAgICBjaGFubmVscy5yZXF1ZXN0LnB1Ymxpc2goY29udGV4dCk7XG4gICAgICByZXR1cm4gKCkgPT4gY2hhbm5lbHMuYWJvcnQucHVibGlzaCgpO1xuICAgIH0pXG4gIH07XG59XG5mdW5jdGlvbiBub3JtYWxpemVyKHN0YWdlKSB7XG4gIHJldHVybiBwcm9nID0+ICh7XG4gICAgc3RhZ2UsXG4gICAgcGVyY2VudDogcHJvZy5wZXJjZW50YWdlLFxuICAgIHRvdGFsOiBwcm9nLmxlbmd0aCxcbiAgICBsb2FkZWQ6IHByb2cudHJhbnNmZXJyZWQsXG4gICAgbGVuZ3RoQ29tcHV0YWJsZTogIShwcm9nLmxlbmd0aCA9PT0gMCAmJiBwcm9nLnBlcmNlbnRhZ2UgPT09IDApXG4gIH0pO1xufVxuZnVuY3Rpb24gcHJvZ3Jlc3MoKSB7XG4gIHJldHVybiB7XG4gICAgb25IZWFkZXJzOiAocmVzcG9uc2UsIGV2dCkgPT4ge1xuICAgICAgY29uc3QgX3Byb2dyZXNzID0gcHJvZ3Jlc3NTdHJlYW1fX2RlZmF1bHQuZGVmYXVsdCh7XG4gICAgICAgIHRpbWU6IDE2XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZSA9IG5vcm1hbGl6ZXIoXCJkb3dubG9hZFwiKTtcbiAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSByZXNwb25zZS5oZWFkZXJzW1wiY29udGVudC1sZW5ndGhcIl07XG4gICAgICBjb25zdCBsZW5ndGggPSBjb250ZW50TGVuZ3RoID8gTnVtYmVyKGNvbnRlbnRMZW5ndGgpIDogMDtcbiAgICAgIGlmICghaXNOYU4obGVuZ3RoKSAmJiBsZW5ndGggPiAwKSB7XG4gICAgICAgIF9wcm9ncmVzcy5zZXRMZW5ndGgobGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIF9wcm9ncmVzcy5vbihcInByb2dyZXNzXCIsIHByb2cgPT4gZXZ0LmNvbnRleHQuY2hhbm5lbHMucHJvZ3Jlc3MucHVibGlzaChub3JtYWxpemUocHJvZykpKTtcbiAgICAgIHJldHVybiByZXNwb25zZS5waXBlKF9wcm9ncmVzcyk7XG4gICAgfSxcbiAgICBvblJlcXVlc3Q6IGV2dCA9PiB7XG4gICAgICBpZiAoIWV2dC5wcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBub3JtYWxpemUgPSBub3JtYWxpemVyKFwidXBsb2FkXCIpO1xuICAgICAgZXZ0LnByb2dyZXNzLm9uKFwicHJvZ3Jlc3NcIiwgcHJvZyA9PiBldnQuY29udGV4dC5jaGFubmVscy5wcm9ncmVzcy5wdWJsaXNoKG5vcm1hbGl6ZShwcm9nKSkpO1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IHByb21pc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgY29uc3QgUHJvbWlzZUltcGxlbWVudGF0aW9uID0gb3B0aW9ucy5pbXBsZW1lbnRhdGlvbiB8fCBQcm9taXNlO1xuICBpZiAoIVByb21pc2VJbXBsZW1lbnRhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImBQcm9taXNlYCBpcyBub3QgYXZhaWxhYmxlIGluIGdsb2JhbCBzY29wZSwgYW5kIG5vIGltcGxlbWVudGF0aW9uIHdhcyBwYXNzZWRcIik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBvblJldHVybjogKGNoYW5uZWxzLCBjb250ZXh0KSA9PiBuZXcgUHJvbWlzZUltcGxlbWVudGF0aW9uKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGNhbmNlbCA9IGNvbnRleHQub3B0aW9ucy5jYW5jZWxUb2tlbjtcbiAgICAgIGlmIChjYW5jZWwpIHtcbiAgICAgICAgY2FuY2VsLnByb21pc2UudGhlbihyZWFzb24gPT4ge1xuICAgICAgICAgIGNoYW5uZWxzLmFib3J0LnB1Ymxpc2gocmVhc29uKTtcbiAgICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjaGFubmVscy5lcnJvci5zdWJzY3JpYmUocmVqZWN0KTtcbiAgICAgIGNoYW5uZWxzLnJlc3BvbnNlLnN1YnNjcmliZShyZXNwb25zZSA9PiB7XG4gICAgICAgIHJlc29sdmUob3B0aW9ucy5vbmx5Qm9keSA/IHJlc3BvbnNlLmJvZHkgOiByZXNwb25zZSk7XG4gICAgICB9KTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNoYW5uZWxzLnJlcXVlc3QucHVibGlzaChjb250ZXh0KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH0pXG4gIH07XG59O1xuY2xhc3MgQ2FuY2VsIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHRoaXMuX19DQU5DRUxfXyA9IHRydWU7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCJDYW5jZWxcIi5jb25jYXQodGhpcy5tZXNzYWdlID8gXCI6IFwiLmNvbmNhdCh0aGlzLm1lc3NhZ2UpIDogXCJcIik7XG4gIH1cbn1cbmNvbnN0IF9DYW5jZWxUb2tlbiA9IGNsYXNzIF9DYW5jZWxUb2tlbiB7XG4gIGNvbnN0cnVjdG9yKGV4ZWN1dG9yKSB7XG4gICAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG4gICAgbGV0IHJlc29sdmVQcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgICB9KTtcbiAgICBleGVjdXRvcihtZXNzYWdlID0+IHtcbiAgICAgIGlmICh0aGlzLnJlYXNvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnJlYXNvbiA9IG5ldyBDYW5jZWwobWVzc2FnZSk7XG4gICAgICByZXNvbHZlUHJvbWlzZSh0aGlzLnJlYXNvbik7XG4gICAgfSk7XG4gIH1cbn07XG5fQ2FuY2VsVG9rZW4uc291cmNlID0gKCkgPT4ge1xuICBsZXQgY2FuY2VsO1xuICBjb25zdCB0b2tlbiA9IG5ldyBfQ2FuY2VsVG9rZW4oY2FuID0+IHtcbiAgICBjYW5jZWwgPSBjYW47XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHRva2VuLFxuICAgIGNhbmNlbFxuICB9O1xufTtcbmxldCBDYW5jZWxUb2tlbiA9IF9DYW5jZWxUb2tlbjtcbmNvbnN0IGlzQ2FuY2VsID0gdmFsdWUgPT4gISEodmFsdWUgJiYgKHZhbHVlID09IG51bGwgPyB2b2lkIDAgOiB2YWx1ZS5fX0NBTkNFTF9fKSk7XG5wcm9taXNlLkNhbmNlbCA9IENhbmNlbDtcbnByb21pc2UuQ2FuY2VsVG9rZW4gPSBDYW5jZWxUb2tlbjtcbnByb21pc2UuaXNDYW5jZWwgPSBpc0NhbmNlbDtcbmZ1bmN0aW9uIHByb3h5KF9wcm94eSkge1xuICBpZiAoX3Byb3h5ICE9PSBmYWxzZSAmJiAoIV9wcm94eSB8fCAhX3Byb3h5Lmhvc3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUHJveHkgbWlkZGxld2FyZSB0YWtlcyBhbiBvYmplY3Qgb2YgaG9zdCwgcG9ydCBhbmQgYXV0aCBwcm9wZXJ0aWVzXCIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgcHJvY2Vzc09wdGlvbnM6IG9wdGlvbnMgPT4gT2JqZWN0LmFzc2lnbih7XG4gICAgICBwcm94eTogX3Byb3h5XG4gICAgfSwgb3B0aW9ucylcbiAgfTtcbn1cbnZhciBkZWZhdWx0U2hvdWxkUmV0cnkgPSAoZXJyLCBudW0sIG9wdGlvbnMpID0+IHtcbiAgaWYgKG9wdGlvbnMubWV0aG9kICE9PSBcIkdFVFwiICYmIG9wdGlvbnMubWV0aG9kICE9PSBcIkhFQURcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZXJyLnJlc3BvbnNlICYmIGVyci5yZXNwb25zZS5zdGF0dXNDb2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBhbGxvd2VkX19kZWZhdWx0LmRlZmF1bHQoZXJyKTtcbn07XG5jb25zdCBpc1N0cmVhbSA9IHN0cmVhbSA9PiBzdHJlYW0gIT09IG51bGwgJiYgdHlwZW9mIHN0cmVhbSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygc3RyZWFtLnBpcGUgPT09IFwiZnVuY3Rpb25cIjtcbnZhciBzaGFyZWRSZXRyeSA9IG9wdHMgPT4ge1xuICBjb25zdCBtYXhSZXRyaWVzID0gb3B0cy5tYXhSZXRyaWVzIHx8IDU7XG4gIGNvbnN0IHJldHJ5RGVsYXkgPSBvcHRzLnJldHJ5RGVsYXkgfHwgZ2V0UmV0cnlEZWxheTtcbiAgY29uc3QgYWxsb3dSZXRyeSA9IG9wdHMuc2hvdWxkUmV0cnk7XG4gIHJldHVybiB7XG4gICAgb25FcnJvcjogKGVyciwgY29udGV4dCkgPT4ge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IGNvbnRleHQub3B0aW9ucztcbiAgICAgIGNvbnN0IG1heCA9IG9wdGlvbnMubWF4UmV0cmllcyB8fCBtYXhSZXRyaWVzO1xuICAgICAgY29uc3Qgc2hvdWxkUmV0cnkgPSBvcHRpb25zLnNob3VsZFJldHJ5IHx8IGFsbG93UmV0cnk7XG4gICAgICBjb25zdCBhdHRlbXB0TnVtYmVyID0gb3B0aW9ucy5hdHRlbXB0TnVtYmVyIHx8IDA7XG4gICAgICBpZiAoaXNTdHJlYW0ob3B0aW9ucy5ib2R5KSkge1xuICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgfVxuICAgICAgaWYgKCFzaG91bGRSZXRyeShlcnIsIGF0dGVtcHROdW1iZXIsIG9wdGlvbnMpIHx8IGF0dGVtcHROdW1iZXIgPj0gbWF4KSB7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdDb250ZXh0ID0gT2JqZWN0LmFzc2lnbih7fSwgY29udGV4dCwge1xuICAgICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgYXR0ZW1wdE51bWJlcjogYXR0ZW1wdE51bWJlciArIDFcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiBjb250ZXh0LmNoYW5uZWxzLnJlcXVlc3QucHVibGlzaChuZXdDb250ZXh0KSwgcmV0cnlEZWxheShhdHRlbXB0TnVtYmVyKSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG59O1xuZnVuY3Rpb24gZ2V0UmV0cnlEZWxheShhdHRlbXB0TnVtKSB7XG4gIHJldHVybiAxMDAgKiBNYXRoLnBvdygyLCBhdHRlbXB0TnVtKSArIE1hdGgucmFuZG9tKCkgKiAxMDA7XG59XG5jb25zdCByZXRyeSA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICByZXR1cm4gc2hhcmVkUmV0cnkoe1xuICAgIHNob3VsZFJldHJ5OiBkZWZhdWx0U2hvdWxkUmV0cnksXG4gICAgLi4ub3B0c1xuICB9KTtcbn07XG5yZXRyeS5zaG91bGRSZXRyeSA9IGRlZmF1bHRTaG91bGRSZXRyeTtcbmZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XG4gIGNvbnN0IHF1ZXJ5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICBjb25zdCBuZXN0ID0gKG5hbWUsIF92YWx1ZSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gX3ZhbHVlIGluc3RhbmNlb2YgU2V0ID8gQXJyYXkuZnJvbShfdmFsdWUpIDogX3ZhbHVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGNvbnN0IGluZGV4IGluIHZhbHVlKSB7XG4gICAgICAgICAgbmVzdChcIlwiLmNvbmNhdChuYW1lLCBcIltcIikuY29uY2F0KGluZGV4LCBcIl1cIiksIHZhbHVlW2luZGV4XSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXJ5LmFwcGVuZChcIlwiLmNvbmNhdChuYW1lLCBcIltdXCIpLCBcIlwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgZm9yIChjb25zdCBba2V5LCBvYmpdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgICAgICBuZXN0KFwiXCIuY29uY2F0KG5hbWUsIFwiW1wiKS5jb25jYXQoa2V5LCBcIl1cIiksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXJ5LmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhkYXRhKSkge1xuICAgIG5lc3Qoa2V5LCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHF1ZXJ5LnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiB1cmxFbmNvZGVkKCkge1xuICByZXR1cm4ge1xuICAgIHByb2Nlc3NPcHRpb25zOiBvcHRpb25zID0+IHtcbiAgICAgIGNvbnN0IGJvZHkgPSBvcHRpb25zLmJvZHk7XG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICB9XG4gICAgICBjb25zdCBpc1N0cmVhbSA9IHR5cGVvZiBib2R5LnBpcGUgPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgIGNvbnN0IHNob3VsZFNlcmlhbGl6ZSA9ICFpc1N0cmVhbSAmJiAhaXNCdWZmZXIoYm9keSkgJiYgaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KGJvZHkpO1xuICAgICAgaWYgKCFzaG91bGRTZXJpYWxpemUpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBib2R5OiBlbmNvZGUob3B0aW9ucy5ib2R5KSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gYnVpbGRLZWVwQWxpdmUoYWdlbnQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGtlZXBBbGl2ZSgpIHtcbiAgICBsZXQgY29uZmlnID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjb25zdCBtcyA9IGNvbmZpZy5tcyB8fCAxZTM7XG4gICAgY29uc3QgbWF4RnJlZSA9IGNvbmZpZy5tYXhGcmVlIHx8IDI1NjtcbiAgICBjb25zdCBhZ2VudE9wdGlvbnMgPSB7XG4gICAgICBrZWVwQWxpdmU6IHRydWUsXG4gICAgICBrZWVwQWxpdmVNc2VjczogbXMsXG4gICAgICBtYXhGcmVlU29ja2V0czogbWF4RnJlZVxuICAgIH07XG4gICAgcmV0dXJuIGFnZW50KGFnZW50T3B0aW9ucyk7XG4gIH07XG59XG5jb25zdCBrZWVwQWxpdmUgPSBidWlsZEtlZXBBbGl2ZShhZ2VudCk7XG5leHBvcnRzLnByb2Nlc3NPcHRpb25zID0gZGVmYXVsdE9wdGlvbnNWYWxpZGF0b3IucHJvY2Vzc09wdGlvbnM7XG5leHBvcnRzLnZhbGlkYXRlT3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zVmFsaWRhdG9yLnZhbGlkYXRlT3B0aW9ucztcbmV4cG9ydHMuQ2FuY2VsID0gQ2FuY2VsO1xuZXhwb3J0cy5DYW5jZWxUb2tlbiA9IENhbmNlbFRva2VuO1xuZXhwb3J0cy5hZ2VudCA9IGFnZW50O1xuZXhwb3J0cy5iYXNlID0gYmFzZTtcbmV4cG9ydHMuZGVidWcgPSBkZWJ1ZztcbmV4cG9ydHMuaGVhZGVycyA9IGhlYWRlcnM7XG5leHBvcnRzLmh0dHBFcnJvcnMgPSBodHRwRXJyb3JzO1xuZXhwb3J0cy5pbmplY3RSZXNwb25zZSA9IGluamVjdFJlc3BvbnNlO1xuZXhwb3J0cy5qc29uUmVxdWVzdCA9IGpzb25SZXF1ZXN0O1xuZXhwb3J0cy5qc29uUmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG5leHBvcnRzLmtlZXBBbGl2ZSA9IGtlZXBBbGl2ZTtcbmV4cG9ydHMubXRscyA9IG10bHM7XG5leHBvcnRzLm9ic2VydmFibGUgPSBvYnNlcnZhYmxlO1xuZXhwb3J0cy5wcm9ncmVzcyA9IHByb2dyZXNzO1xuZXhwb3J0cy5wcm9taXNlID0gcHJvbWlzZTtcbmV4cG9ydHMucHJveHkgPSBwcm94eTtcbmV4cG9ydHMucmV0cnkgPSByZXRyeTtcbmV4cG9ydHMudXJsRW5jb2RlZCA9IHVybEVuY29kZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1taWRkbGV3YXJlLmNqcy5tYXBcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImh0dHAiLCJyZXF1aXJlIiwiaHR0cHMiLCJkZWJ1Z0l0IiwiZGVmYXVsdE9wdGlvbnNWYWxpZGF0b3IiLCJpc1BsYWluT2JqZWN0IiwicHJvZ3Jlc3NTdHJlYW0iLCJhbGxvd2VkIiwiX2ludGVyb3BEZWZhdWx0Q29tcGF0IiwiZSIsImRlZmF1bHQiLCJkZWJ1Z0l0X19kZWZhdWx0IiwicHJvZ3Jlc3NTdHJlYW1fX2RlZmF1bHQiLCJhbGxvd2VkX19kZWZhdWx0IiwiaXNIdHRwc1Byb3RvIiwiYWdlbnQiLCJvcHRzIiwiaHR0cEFnZW50IiwiQWdlbnQiLCJodHRwc0FnZW50IiwiYWdlbnRzIiwiZmluYWxpemVPcHRpb25zIiwib3B0aW9ucyIsIm1heFJlZGlyZWN0cyIsImlzSHR0cHMiLCJ0ZXN0IiwiaHJlZiIsInByb3RvY29sIiwibGVhZGluZ1NsYXNoIiwidHJhaWxpbmdTbGFzaCIsImJhc2UiLCJiYXNlVXJsIiwiYmFzZVVyaSIsInJlcGxhY2UiLCJwcm9jZXNzT3B0aW9ucyIsInVybCIsImpvaW4iLCJhc3NpZ24iLCJTRU5TSVRJVkVfSEVBREVSUyIsImhhc093biIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwicmVkYWN0S2V5cyIsInNvdXJjZSIsInJlZGFjdGVkIiwidGFyZ2V0Iiwia2V5IiwiY2FsbCIsImluZGV4T2YiLCJ0b0xvd2VyQ2FzZSIsImRlYnVnIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwidmVyYm9zZSIsIm5hbWVzcGFjZSIsImRlZmF1bHRMb2dnZXIiLCJsb2ciLCJzaG9ydENpcmN1aXQiLCJlbmFibGVkIiwicmVxdWVzdElkIiwib25SZXF1ZXN0IiwiZXZlbnQiLCJtZXRob2QiLCJib2R5IiwiaGVhZGVycyIsInJlZGFjdFNlbnNpdGl2ZUhlYWRlcnMiLCJKU09OIiwic3RyaW5naWZ5Iiwib25SZXNwb25zZSIsInJlcyIsImNvbnRleHQiLCJyZXFJZCIsInN0YXR1c0NvZGUiLCJzdGF0dXNNZXNzYWdlIiwic3RyaW5naWZ5Qm9keSIsIm9uRXJyb3IiLCJlcnIiLCJtZXNzYWdlIiwiY29udGVudFR5cGUiLCJpc0pzb24iLCJ0cnlGb3JtYXQiLCJwYXJzZWQiLCJwYXJzZSIsIl9oZWFkZXJzIiwiZXhpc3RpbmciLCJvdmVycmlkZSIsIkh0dHBFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJjdHgiLCJ0cnVuY2F0ZWRVcmwiLCJjb25jYXQiLCJzbGljZSIsIm1zZyIsInRyaW0iLCJyZXNwb25zZSIsInJlcXVlc3QiLCJodHRwRXJyb3JzIiwiaXNIdHRwRXJyb3IiLCJpbmplY3RSZXNwb25zZSIsImluamVjdCIsImluamVjdDIiLCJwcmV2VmFsdWUiLCJpbnRlcmNlcHRSZXF1ZXN0IiwiaXNCdWZmZXIiLCJCdWZmZXIiLCJvYmoiLCJzZXJpYWxpemVUeXBlcyIsImpzb25SZXF1ZXN0IiwiaXNTdHJlYW0iLCJwaXBlIiwic2hvdWxkU2VyaWFsaXplIiwiQXJyYXkiLCJpc0FycmF5IiwianNvblJlc3BvbnNlIiwic2hvdWxkRGVjb2RlIiwiZm9yY2UiLCJ0cnlQYXJzZSIsIkFjY2VwdCIsImlzQnJvd3Nlck9wdGlvbnMiLCJtdGxzIiwiY29uZmlnIiwiY2EiLCJjZXJ0IiwibXRsc09wdHMiLCJhY3R1YWxHbG9iYWwiLCJnbG9iYWxUaGlzIiwid2luZG93IiwiZ2xvYmFsIiwic2VsZiIsImdsb2JhbCQxIiwib2JzZXJ2YWJsZSIsIk9ic2VydmFibGUiLCJpbXBsZW1lbnRhdGlvbiIsIm9uUmV0dXJuIiwiY2hhbm5lbHMiLCJvYnNlcnZlciIsImVycm9yIiwic3Vic2NyaWJlIiwicHJvZ3Jlc3MiLCJuZXh0IiwidHlwZSIsImNvbXBsZXRlIiwicHVibGlzaCIsImFib3J0Iiwibm9ybWFsaXplciIsInN0YWdlIiwicHJvZyIsInBlcmNlbnQiLCJwZXJjZW50YWdlIiwidG90YWwiLCJsb2FkZWQiLCJ0cmFuc2ZlcnJlZCIsImxlbmd0aENvbXB1dGFibGUiLCJvbkhlYWRlcnMiLCJldnQiLCJfcHJvZ3Jlc3MiLCJ0aW1lIiwibm9ybWFsaXplIiwiY29udGVudExlbmd0aCIsIk51bWJlciIsImlzTmFOIiwic2V0TGVuZ3RoIiwib24iLCJwcm9taXNlIiwiUHJvbWlzZUltcGxlbWVudGF0aW9uIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjYW5jZWwiLCJjYW5jZWxUb2tlbiIsInRoZW4iLCJyZWFzb24iLCJvbmx5Qm9keSIsInNldFRpbWVvdXQiLCJDYW5jZWwiLCJfX0NBTkNFTF9fIiwidG9TdHJpbmciLCJfQ2FuY2VsVG9rZW4iLCJleGVjdXRvciIsIlR5cGVFcnJvciIsInJlc29sdmVQcm9taXNlIiwidG9rZW4iLCJjYW4iLCJDYW5jZWxUb2tlbiIsImlzQ2FuY2VsIiwicHJveHkiLCJfcHJveHkiLCJob3N0IiwiZGVmYXVsdFNob3VsZFJldHJ5IiwibnVtIiwic3RyZWFtIiwic2hhcmVkUmV0cnkiLCJtYXhSZXRyaWVzIiwicmV0cnlEZWxheSIsImdldFJldHJ5RGVsYXkiLCJhbGxvd1JldHJ5Iiwic2hvdWxkUmV0cnkiLCJtYXgiLCJhdHRlbXB0TnVtYmVyIiwibmV3Q29udGV4dCIsImF0dGVtcHROdW0iLCJNYXRoIiwicG93IiwicmFuZG9tIiwicmV0cnkiLCJlbmNvZGUiLCJkYXRhIiwicXVlcnkiLCJVUkxTZWFyY2hQYXJhbXMiLCJuZXN0IiwibmFtZSIsIl92YWx1ZSIsIlNldCIsImZyb20iLCJpbmRleCIsImFwcGVuZCIsImVudHJpZXMiLCJ1cmxFbmNvZGVkIiwiYnVpbGRLZWVwQWxpdmUiLCJrZWVwQWxpdmUiLCJtcyIsIm1heEZyZWUiLCJhZ2VudE9wdGlvbnMiLCJrZWVwQWxpdmVNc2VjcyIsIm1heEZyZWVTb2NrZXRzIiwidmFsaWRhdGVPcHRpb25zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/get-it/dist/middleware.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/get-it/dist/_chunks/createRequester-ryeXkh0z.js":
/*!**********************************************************************!*\
  !*** ./node_modules/get-it/dist/_chunks/createRequester-ryeXkh0z.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createRequester: () => (/* binding */ createRequester)\n/* harmony export */ });\n/* harmony import */ var _defaultOptionsValidator_dittwL7d_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaultOptionsValidator-dittwL7d.js */ \"(rsc)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-dittwL7d.js\");\n\nconst middlewareReducer = (middleware)=>function applyMiddleware(hook, defaultValue) {\n        const bailEarly = hook === \"onError\";\n        let value = defaultValue;\n        for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){\n            args[_key - 2] = arguments[_key];\n        }\n        for(let i = 0; i < middleware[hook].length; i++){\n            const handler = middleware[hook][i];\n            value = handler(value, ...args);\n            if (bailEarly && !value) {\n                break;\n            }\n        }\n        return value;\n    };\nfunction createPubSub() {\n    const subscribers = /* @__PURE__ */ Object.create(null);\n    let nextId = 0;\n    function subscribe(subscriber) {\n        const id = nextId++;\n        subscribers[id] = subscriber;\n        return function unsubscribe() {\n            delete subscribers[id];\n        };\n    }\n    function publish(event) {\n        for(const id in subscribers){\n            subscribers[id](event);\n        }\n    }\n    return {\n        publish,\n        subscribe\n    };\n}\nconst channelNames = [\n    \"request\",\n    \"response\",\n    \"progress\",\n    \"error\",\n    \"abort\"\n];\nconst middlehooks = [\n    \"processOptions\",\n    \"validateOptions\",\n    \"interceptRequest\",\n    \"finalizeOptions\",\n    \"onRequest\",\n    \"onResponse\",\n    \"onError\",\n    \"onReturn\",\n    \"onHeaders\"\n];\nfunction createRequester(initMiddleware, httpRequest) {\n    const loadedMiddleware = [];\n    const middleware = middlehooks.reduce((ware, name)=>{\n        ware[name] = ware[name] || [];\n        return ware;\n    }, {\n        processOptions: [\n            _defaultOptionsValidator_dittwL7d_js__WEBPACK_IMPORTED_MODULE_0__.processOptions\n        ],\n        validateOptions: [\n            _defaultOptionsValidator_dittwL7d_js__WEBPACK_IMPORTED_MODULE_0__.validateOptions\n        ]\n    });\n    function request(opts) {\n        const onResponse = (reqErr, res, ctx)=>{\n            let error = reqErr;\n            let response = res;\n            if (!error) {\n                try {\n                    response = applyMiddleware(\"onResponse\", res, ctx);\n                } catch (err) {\n                    response = null;\n                    error = err;\n                }\n            }\n            error = error && applyMiddleware(\"onError\", error, ctx);\n            if (error) {\n                channels.error.publish(error);\n            } else if (response) {\n                channels.response.publish(response);\n            }\n        };\n        const channels = channelNames.reduce((target, name)=>{\n            target[name] = createPubSub();\n            return target;\n        }, {});\n        const applyMiddleware = middlewareReducer(middleware);\n        const options = applyMiddleware(\"processOptions\", opts);\n        applyMiddleware(\"validateOptions\", options);\n        const context = {\n            options,\n            channels,\n            applyMiddleware\n        };\n        let ongoingRequest;\n        const unsubscribe = channels.request.subscribe((ctx)=>{\n            ongoingRequest = httpRequest(ctx, (err, res)=>onResponse(err, res, ctx));\n        });\n        channels.abort.subscribe(()=>{\n            unsubscribe();\n            if (ongoingRequest) {\n                ongoingRequest.abort();\n            }\n        });\n        const returnValue = applyMiddleware(\"onReturn\", channels, context);\n        if (returnValue === channels) {\n            channels.request.publish(context);\n        }\n        return returnValue;\n    }\n    request.use = function use(newMiddleware) {\n        if (!newMiddleware) {\n            throw new Error(\"Tried to add middleware that resolved to falsey value\");\n        }\n        if (typeof newMiddleware === \"function\") {\n            throw new Error(\"Tried to add middleware that was a function. It probably expects you to pass options to it.\");\n        }\n        if (newMiddleware.onReturn && middleware.onReturn.length > 0) {\n            throw new Error(\"Tried to add new middleware with `onReturn` handler, but another handler has already been registered for this event\");\n        }\n        middlehooks.forEach((key)=>{\n            if (newMiddleware[key]) {\n                middleware[key].push(newMiddleware[key]);\n            }\n        });\n        loadedMiddleware.push(newMiddleware);\n        return request;\n    };\n    request.clone = ()=>createRequester(loadedMiddleware, httpRequest);\n    initMiddleware.forEach(request.use);\n    return request;\n}\n //# sourceMappingURL=createRequester-ryeXkh0z.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvX2NodW5rcy9jcmVhdGVSZXF1ZXN0ZXItcnllWGtoMHouanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBd0Y7QUFDeEYsTUFBTUUsb0JBQW9CQyxDQUFBQSxhQUFjLFNBQVNDLGdCQUFnQkMsSUFBSSxFQUFFQyxZQUFZO1FBQ2pGLE1BQU1DLFlBQVlGLFNBQVM7UUFDM0IsSUFBSUcsUUFBUUY7UUFDWixJQUFLLElBQUlHLE9BQU9DLFVBQVVDLE1BQU0sRUFBRUMsT0FBTyxJQUFJQyxNQUFNSixPQUFPLElBQUlBLE9BQU8sSUFBSSxJQUFJSyxPQUFPLEdBQUdBLE9BQU9MLE1BQU1LLE9BQVE7WUFDMUdGLElBQUksQ0FBQ0UsT0FBTyxFQUFFLEdBQUdKLFNBQVMsQ0FBQ0ksS0FBSztRQUNsQztRQUNBLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJWixVQUFVLENBQUNFLEtBQUssQ0FBQ00sTUFBTSxFQUFFSSxJQUFLO1lBQ2hELE1BQU1DLFVBQVViLFVBQVUsQ0FBQ0UsS0FBSyxDQUFDVSxFQUFFO1lBQ25DUCxRQUFRUSxRQUFRUixVQUFVSTtZQUMxQixJQUFJTCxhQUFhLENBQUNDLE9BQU87Z0JBQ3ZCO1lBQ0Y7UUFDRjtRQUNBLE9BQU9BO0lBQ1Q7QUFDQSxTQUFTUztJQUNQLE1BQU1DLGNBQWMsYUFBYSxHQUFFQyxPQUFPQyxNQUFNLENBQUM7SUFDakQsSUFBSUMsU0FBUztJQUNiLFNBQVNDLFVBQVVDLFVBQVU7UUFDM0IsTUFBTUMsS0FBS0g7UUFDWEgsV0FBVyxDQUFDTSxHQUFHLEdBQUdEO1FBQ2xCLE9BQU8sU0FBU0U7WUFDZCxPQUFPUCxXQUFXLENBQUNNLEdBQUc7UUFDeEI7SUFDRjtJQUNBLFNBQVNFLFFBQVFDLEtBQUs7UUFDcEIsSUFBSyxNQUFNSCxNQUFNTixZQUFhO1lBQzVCQSxXQUFXLENBQUNNLEdBQUcsQ0FBQ0c7UUFDbEI7SUFDRjtJQUNBLE9BQU87UUFDTEQ7UUFDQUo7SUFDRjtBQUNG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REQsZUFBZTBCLE9BQU8sQ0FBQ3BCLFFBQVFnQixHQUFHO0lBQ2xDLE9BQU9oQjtBQUNUO0FBQzJCLENBQzNCLG9EQUFvRCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1jb21tZXJjZS15dC1ieS1taWtlLy4vbm9kZV9tb2R1bGVzL2dldC1pdC9kaXN0L19jaHVua3MvY3JlYXRlUmVxdWVzdGVyLXJ5ZVhraDB6LmpzPzg3OTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcHJvY2Vzc09wdGlvbnMsIHZhbGlkYXRlT3B0aW9ucyB9IGZyb20gJy4vZGVmYXVsdE9wdGlvbnNWYWxpZGF0b3ItZGl0dHdMN2QuanMnO1xuY29uc3QgbWlkZGxld2FyZVJlZHVjZXIgPSBtaWRkbGV3YXJlID0+IGZ1bmN0aW9uIGFwcGx5TWlkZGxld2FyZShob29rLCBkZWZhdWx0VmFsdWUpIHtcbiAgY29uc3QgYmFpbEVhcmx5ID0gaG9vayA9PT0gXCJvbkVycm9yXCI7XG4gIGxldCB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWlkZGxld2FyZVtob29rXS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGhhbmRsZXIgPSBtaWRkbGV3YXJlW2hvb2tdW2ldO1xuICAgIHZhbHVlID0gaGFuZGxlcih2YWx1ZSwgLi4uYXJncyk7XG4gICAgaWYgKGJhaWxFYXJseSAmJiAhdmFsdWUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xuZnVuY3Rpb24gY3JlYXRlUHViU3ViKCkge1xuICBjb25zdCBzdWJzY3JpYmVycyA9IC8qIEBfX1BVUkVfXyAqL09iamVjdC5jcmVhdGUobnVsbCk7XG4gIGxldCBuZXh0SWQgPSAwO1xuICBmdW5jdGlvbiBzdWJzY3JpYmUoc3Vic2NyaWJlcikge1xuICAgIGNvbnN0IGlkID0gbmV4dElkKys7XG4gICAgc3Vic2NyaWJlcnNbaWRdID0gc3Vic2NyaWJlcjtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICBkZWxldGUgc3Vic2NyaWJlcnNbaWRdO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gcHVibGlzaChldmVudCkge1xuICAgIGZvciAoY29uc3QgaWQgaW4gc3Vic2NyaWJlcnMpIHtcbiAgICAgIHN1YnNjcmliZXJzW2lkXShldmVudCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgcHVibGlzaCxcbiAgICBzdWJzY3JpYmVcbiAgfTtcbn1cbmNvbnN0IGNoYW5uZWxOYW1lcyA9IFtcInJlcXVlc3RcIiwgXCJyZXNwb25zZVwiLCBcInByb2dyZXNzXCIsIFwiZXJyb3JcIiwgXCJhYm9ydFwiXTtcbmNvbnN0IG1pZGRsZWhvb2tzID0gW1wicHJvY2Vzc09wdGlvbnNcIiwgXCJ2YWxpZGF0ZU9wdGlvbnNcIiwgXCJpbnRlcmNlcHRSZXF1ZXN0XCIsIFwiZmluYWxpemVPcHRpb25zXCIsIFwib25SZXF1ZXN0XCIsIFwib25SZXNwb25zZVwiLCBcIm9uRXJyb3JcIiwgXCJvblJldHVyblwiLCBcIm9uSGVhZGVyc1wiXTtcbmZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3Rlcihpbml0TWlkZGxld2FyZSwgaHR0cFJlcXVlc3QpIHtcbiAgY29uc3QgbG9hZGVkTWlkZGxld2FyZSA9IFtdO1xuICBjb25zdCBtaWRkbGV3YXJlID0gbWlkZGxlaG9va3MucmVkdWNlKCh3YXJlLCBuYW1lKSA9PiB7XG4gICAgd2FyZVtuYW1lXSA9IHdhcmVbbmFtZV0gfHwgW107XG4gICAgcmV0dXJuIHdhcmU7XG4gIH0sIHtcbiAgICBwcm9jZXNzT3B0aW9uczogW3Byb2Nlc3NPcHRpb25zXSxcbiAgICB2YWxpZGF0ZU9wdGlvbnM6IFt2YWxpZGF0ZU9wdGlvbnNdXG4gIH0pO1xuICBmdW5jdGlvbiByZXF1ZXN0KG9wdHMpIHtcbiAgICBjb25zdCBvblJlc3BvbnNlID0gKHJlcUVyciwgcmVzLCBjdHgpID0+IHtcbiAgICAgIGxldCBlcnJvciA9IHJlcUVycjtcbiAgICAgIGxldCByZXNwb25zZSA9IHJlcztcbiAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXNwb25zZSA9IGFwcGx5TWlkZGxld2FyZShcIm9uUmVzcG9uc2VcIiwgcmVzLCBjdHgpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZXNwb25zZSA9IG51bGw7XG4gICAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVycm9yID0gZXJyb3IgJiYgYXBwbHlNaWRkbGV3YXJlKFwib25FcnJvclwiLCBlcnJvciwgY3R4KTtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjaGFubmVscy5lcnJvci5wdWJsaXNoKGVycm9yKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgY2hhbm5lbHMucmVzcG9uc2UucHVibGlzaChyZXNwb25zZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBjaGFubmVscyA9IGNoYW5uZWxOYW1lcy5yZWR1Y2UoKHRhcmdldCwgbmFtZSkgPT4ge1xuICAgICAgdGFyZ2V0W25hbWVdID0gY3JlYXRlUHViU3ViKCk7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0sIHt9KTtcbiAgICBjb25zdCBhcHBseU1pZGRsZXdhcmUgPSBtaWRkbGV3YXJlUmVkdWNlcihtaWRkbGV3YXJlKTtcbiAgICBjb25zdCBvcHRpb25zID0gYXBwbHlNaWRkbGV3YXJlKFwicHJvY2Vzc09wdGlvbnNcIiwgb3B0cyk7XG4gICAgYXBwbHlNaWRkbGV3YXJlKFwidmFsaWRhdGVPcHRpb25zXCIsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBvcHRpb25zLFxuICAgICAgY2hhbm5lbHMsXG4gICAgICBhcHBseU1pZGRsZXdhcmVcbiAgICB9O1xuICAgIGxldCBvbmdvaW5nUmVxdWVzdDtcbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IGNoYW5uZWxzLnJlcXVlc3Quc3Vic2NyaWJlKGN0eCA9PiB7XG4gICAgICBvbmdvaW5nUmVxdWVzdCA9IGh0dHBSZXF1ZXN0KGN0eCwgKGVyciwgcmVzKSA9PiBvblJlc3BvbnNlKGVyciwgcmVzLCBjdHgpKTtcbiAgICB9KTtcbiAgICBjaGFubmVscy5hYm9ydC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgIGlmIChvbmdvaW5nUmVxdWVzdCkge1xuICAgICAgICBvbmdvaW5nUmVxdWVzdC5hYm9ydCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHJldHVyblZhbHVlID0gYXBwbHlNaWRkbGV3YXJlKFwib25SZXR1cm5cIiwgY2hhbm5lbHMsIGNvbnRleHQpO1xuICAgIGlmIChyZXR1cm5WYWx1ZSA9PT0gY2hhbm5lbHMpIHtcbiAgICAgIGNoYW5uZWxzLnJlcXVlc3QucHVibGlzaChjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICB9XG4gIHJlcXVlc3QudXNlID0gZnVuY3Rpb24gdXNlKG5ld01pZGRsZXdhcmUpIHtcbiAgICBpZiAoIW5ld01pZGRsZXdhcmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyaWVkIHRvIGFkZCBtaWRkbGV3YXJlIHRoYXQgcmVzb2x2ZWQgdG8gZmFsc2V5IHZhbHVlXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5ld01pZGRsZXdhcmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJpZWQgdG8gYWRkIG1pZGRsZXdhcmUgdGhhdCB3YXMgYSBmdW5jdGlvbi4gSXQgcHJvYmFibHkgZXhwZWN0cyB5b3UgdG8gcGFzcyBvcHRpb25zIHRvIGl0LlwiKTtcbiAgICB9XG4gICAgaWYgKG5ld01pZGRsZXdhcmUub25SZXR1cm4gJiYgbWlkZGxld2FyZS5vblJldHVybi5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmllZCB0byBhZGQgbmV3IG1pZGRsZXdhcmUgd2l0aCBgb25SZXR1cm5gIGhhbmRsZXIsIGJ1dCBhbm90aGVyIGhhbmRsZXIgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIGZvciB0aGlzIGV2ZW50XCIpO1xuICAgIH1cbiAgICBtaWRkbGVob29rcy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAobmV3TWlkZGxld2FyZVtrZXldKSB7XG4gICAgICAgIG1pZGRsZXdhcmVba2V5XS5wdXNoKG5ld01pZGRsZXdhcmVba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbG9hZGVkTWlkZGxld2FyZS5wdXNoKG5ld01pZGRsZXdhcmUpO1xuICAgIHJldHVybiByZXF1ZXN0O1xuICB9O1xuICByZXF1ZXN0LmNsb25lID0gKCkgPT4gY3JlYXRlUmVxdWVzdGVyKGxvYWRlZE1pZGRsZXdhcmUsIGh0dHBSZXF1ZXN0KTtcbiAgaW5pdE1pZGRsZXdhcmUuZm9yRWFjaChyZXF1ZXN0LnVzZSk7XG4gIHJldHVybiByZXF1ZXN0O1xufVxuZXhwb3J0IHsgY3JlYXRlUmVxdWVzdGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVSZXF1ZXN0ZXItcnllWGtoMHouanMubWFwXG4iXSwibmFtZXMiOlsicHJvY2Vzc09wdGlvbnMiLCJ2YWxpZGF0ZU9wdGlvbnMiLCJtaWRkbGV3YXJlUmVkdWNlciIsIm1pZGRsZXdhcmUiLCJhcHBseU1pZGRsZXdhcmUiLCJob29rIiwiZGVmYXVsdFZhbHVlIiwiYmFpbEVhcmx5IiwidmFsdWUiLCJfbGVuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiYXJncyIsIkFycmF5IiwiX2tleSIsImkiLCJoYW5kbGVyIiwiY3JlYXRlUHViU3ViIiwic3Vic2NyaWJlcnMiLCJPYmplY3QiLCJjcmVhdGUiLCJuZXh0SWQiLCJzdWJzY3JpYmUiLCJzdWJzY3JpYmVyIiwiaWQiLCJ1bnN1YnNjcmliZSIsInB1Ymxpc2giLCJldmVudCIsImNoYW5uZWxOYW1lcyIsIm1pZGRsZWhvb2tzIiwiY3JlYXRlUmVxdWVzdGVyIiwiaW5pdE1pZGRsZXdhcmUiLCJodHRwUmVxdWVzdCIsImxvYWRlZE1pZGRsZXdhcmUiLCJyZWR1Y2UiLCJ3YXJlIiwibmFtZSIsInJlcXVlc3QiLCJvcHRzIiwib25SZXNwb25zZSIsInJlcUVyciIsInJlcyIsImN0eCIsImVycm9yIiwicmVzcG9uc2UiLCJlcnIiLCJjaGFubmVscyIsInRhcmdldCIsIm9wdGlvbnMiLCJjb250ZXh0Iiwib25nb2luZ1JlcXVlc3QiLCJhYm9ydCIsInJldHVyblZhbHVlIiwidXNlIiwibmV3TWlkZGxld2FyZSIsIkVycm9yIiwib25SZXR1cm4iLCJmb3JFYWNoIiwia2V5IiwicHVzaCIsImNsb25lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/get-it/dist/_chunks/createRequester-ryeXkh0z.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-dittwL7d.js":
/*!******************************************************************************!*\
  !*** ./node_modules/get-it/dist/_chunks/defaultOptionsValidator-dittwL7d.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   processOptions: () => (/* binding */ processOptions),\n/* harmony export */   validateOptions: () => (/* binding */ validateOptions)\n/* harmony export */ });\nconst isReactNative = typeof navigator === \"undefined\" ? false : navigator.product === \"ReactNative\";\nconst defaultOptions = {\n    timeout: isReactNative ? 6e4 : 12e4\n};\nconst processOptions = function processOptions2(opts) {\n    const options = {\n        ...defaultOptions,\n        ...typeof opts === \"string\" ? {\n            url: opts\n        } : opts\n    };\n    const { searchParams } = new URL(options.url, \"http://localhost\");\n    options.timeout = normalizeTimeout(options.timeout);\n    if (options.query) {\n        for (const [key, value] of Object.entries(options.query)){\n            if (value !== void 0) {\n                if (Array.isArray(value)) {\n                    for (const v of value){\n                        searchParams.append(key, v);\n                    }\n                } else {\n                    searchParams.append(key, value);\n                }\n            }\n        }\n    }\n    const [url] = options.url.split(\"?\");\n    const search = searchParams.toString();\n    if (search) {\n        options.url = \"\".concat(url, \"?\").concat(search);\n    }\n    options.method = options.body && !options.method ? \"POST\" : (options.method || \"GET\").toUpperCase();\n    return options;\n};\nfunction normalizeTimeout(time) {\n    if (time === false || time === 0) {\n        return false;\n    }\n    if (time.connect || time.socket) {\n        return time;\n    }\n    const delay = Number(time);\n    if (isNaN(delay)) {\n        return normalizeTimeout(defaultOptions.timeout);\n    }\n    return {\n        connect: delay,\n        socket: delay\n    };\n}\nconst validUrl = /^https?:\\/\\//i;\nconst validateOptions = function validateOptions2(options) {\n    if (!validUrl.test(options.url)) {\n        throw new Error('\"'.concat(options.url, '\" is not a valid URL'));\n    }\n};\n //# sourceMappingURL=defaultOptionsValidator-dittwL7d.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvX2NodW5rcy9kZWZhdWx0T3B0aW9uc1ZhbGlkYXRvci1kaXR0d0w3ZC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLE1BQU1BLGdCQUFnQixPQUFPQyxjQUFjLGNBQWMsUUFBUUEsVUFBVUMsT0FBTyxLQUFLO0FBQ3ZGLE1BQU1DLGlCQUFpQjtJQUNyQkMsU0FBU0osZ0JBQWdCLE1BQU07QUFDakM7QUFDQSxNQUFNSyxpQkFBaUIsU0FBU0MsZ0JBQWdCQyxJQUFJO0lBQ2xELE1BQU1DLFVBQVU7UUFDZCxHQUFHTCxjQUFjO1FBQ2pCLEdBQUksT0FBT0ksU0FBUyxXQUFXO1lBQzdCRSxLQUFLRjtRQUNQLElBQUlBLElBQUk7SUFDVjtJQUNBLE1BQU0sRUFDSkcsWUFBWSxFQUNiLEdBQUcsSUFBSUMsSUFBSUgsUUFBUUMsR0FBRyxFQUFFO0lBQ3pCRCxRQUFRSixPQUFPLEdBQUdRLGlCQUFpQkosUUFBUUosT0FBTztJQUNsRCxJQUFJSSxRQUFRSyxLQUFLLEVBQUU7UUFDakIsS0FBSyxNQUFNLENBQUNDLEtBQUtDLE1BQU0sSUFBSUMsT0FBT0MsT0FBTyxDQUFDVCxRQUFRSyxLQUFLLEVBQUc7WUFDeEQsSUFBSUUsVUFBVSxLQUFLLEdBQUc7Z0JBQ3BCLElBQUlHLE1BQU1DLE9BQU8sQ0FBQ0osUUFBUTtvQkFDeEIsS0FBSyxNQUFNSyxLQUFLTCxNQUFPO3dCQUNyQkwsYUFBYVcsTUFBTSxDQUFDUCxLQUFLTTtvQkFDM0I7Z0JBQ0YsT0FBTztvQkFDTFYsYUFBYVcsTUFBTSxDQUFDUCxLQUFLQztnQkFDM0I7WUFDRjtRQUNGO0lBQ0Y7SUFDQSxNQUFNLENBQUNOLElBQUksR0FBR0QsUUFBUUMsR0FBRyxDQUFDYSxLQUFLLENBQUM7SUFDaEMsTUFBTUMsU0FBU2IsYUFBYWMsUUFBUTtJQUNwQyxJQUFJRCxRQUFRO1FBQ1ZmLFFBQVFDLEdBQUcsR0FBRyxHQUFHZ0IsTUFBTSxDQUFDaEIsS0FBSyxLQUFLZ0IsTUFBTSxDQUFDRjtJQUMzQztJQUNBZixRQUFRa0IsTUFBTSxHQUFHbEIsUUFBUW1CLElBQUksSUFBSSxDQUFDbkIsUUFBUWtCLE1BQU0sR0FBRyxTQUFTLENBQUNsQixRQUFRa0IsTUFBTSxJQUFJLEtBQUksRUFBR0UsV0FBVztJQUNqRyxPQUFPcEI7QUFDVDtBQUNBLFNBQVNJLGlCQUFpQmlCLElBQUk7SUFDNUIsSUFBSUEsU0FBUyxTQUFTQSxTQUFTLEdBQUc7UUFDaEMsT0FBTztJQUNUO0lBQ0EsSUFBSUEsS0FBS0MsT0FBTyxJQUFJRCxLQUFLRSxNQUFNLEVBQUU7UUFDL0IsT0FBT0Y7SUFDVDtJQUNBLE1BQU1HLFFBQVFDLE9BQU9KO0lBQ3JCLElBQUlLLE1BQU1GLFFBQVE7UUFDaEIsT0FBT3BCLGlCQUFpQlQsZUFBZUMsT0FBTztJQUNoRDtJQUNBLE9BQU87UUFDTDBCLFNBQVNFO1FBQ1RELFFBQVFDO0lBQ1Y7QUFDRjtBQUNBLE1BQU1HLFdBQVc7QUFDakIsTUFBTUMsa0JBQWtCLFNBQVNDLGlCQUFpQjdCLE9BQU87SUFDdkQsSUFBSSxDQUFDMkIsU0FBU0csSUFBSSxDQUFDOUIsUUFBUUMsR0FBRyxHQUFHO1FBQy9CLE1BQU0sSUFBSThCLE1BQU0sSUFBSWQsTUFBTSxDQUFDakIsUUFBUUMsR0FBRyxFQUFFO0lBQzFDO0FBQ0Y7QUFDMkMsQ0FDM0MsNERBQTREIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLWNvbW1lcmNlLXl0LWJ5LW1pa2UvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvX2NodW5rcy9kZWZhdWx0T3B0aW9uc1ZhbGlkYXRvci1kaXR0d0w3ZC5qcz81MTgwIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGlzUmVhY3ROYXRpdmUgPSB0eXBlb2YgbmF2aWdhdG9yID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gXCJSZWFjdE5hdGl2ZVwiO1xuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIHRpbWVvdXQ6IGlzUmVhY3ROYXRpdmUgPyA2ZTQgOiAxMmU0XG59O1xuY29uc3QgcHJvY2Vzc09wdGlvbnMgPSBmdW5jdGlvbiBwcm9jZXNzT3B0aW9uczIob3B0cykge1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgIC4uLih0eXBlb2Ygb3B0cyA9PT0gXCJzdHJpbmdcIiA/IHtcbiAgICAgIHVybDogb3B0c1xuICAgIH0gOiBvcHRzKVxuICB9O1xuICBjb25zdCB7XG4gICAgc2VhcmNoUGFyYW1zXG4gIH0gPSBuZXcgVVJMKG9wdGlvbnMudXJsLCBcImh0dHA6Ly9sb2NhbGhvc3RcIik7XG4gIG9wdGlvbnMudGltZW91dCA9IG5vcm1hbGl6ZVRpbWVvdXQob3B0aW9ucy50aW1lb3V0KTtcbiAgaWYgKG9wdGlvbnMucXVlcnkpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvcHRpb25zLnF1ZXJ5KSkge1xuICAgICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgICAgICAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgW3VybF0gPSBvcHRpb25zLnVybC5zcGxpdChcIj9cIik7XG4gIGNvbnN0IHNlYXJjaCA9IHNlYXJjaFBhcmFtcy50b1N0cmluZygpO1xuICBpZiAoc2VhcmNoKSB7XG4gICAgb3B0aW9ucy51cmwgPSBcIlwiLmNvbmNhdCh1cmwsIFwiP1wiKS5jb25jYXQoc2VhcmNoKTtcbiAgfVxuICBvcHRpb25zLm1ldGhvZCA9IG9wdGlvbnMuYm9keSAmJiAhb3B0aW9ucy5tZXRob2QgPyBcIlBPU1RcIiA6IChvcHRpb25zLm1ldGhvZCB8fCBcIkdFVFwiKS50b1VwcGVyQ2FzZSgpO1xuICByZXR1cm4gb3B0aW9ucztcbn07XG5mdW5jdGlvbiBub3JtYWxpemVUaW1lb3V0KHRpbWUpIHtcbiAgaWYgKHRpbWUgPT09IGZhbHNlIHx8IHRpbWUgPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHRpbWUuY29ubmVjdCB8fCB0aW1lLnNvY2tldCkge1xuICAgIHJldHVybiB0aW1lO1xuICB9XG4gIGNvbnN0IGRlbGF5ID0gTnVtYmVyKHRpbWUpO1xuICBpZiAoaXNOYU4oZGVsYXkpKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVRpbWVvdXQoZGVmYXVsdE9wdGlvbnMudGltZW91dCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb25uZWN0OiBkZWxheSxcbiAgICBzb2NrZXQ6IGRlbGF5XG4gIH07XG59XG5jb25zdCB2YWxpZFVybCA9IC9eaHR0cHM/OlxcL1xcLy9pO1xuY29uc3QgdmFsaWRhdGVPcHRpb25zID0gZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25zMihvcHRpb25zKSB7XG4gIGlmICghdmFsaWRVcmwudGVzdChvcHRpb25zLnVybCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJy5jb25jYXQob3B0aW9ucy51cmwsICdcIiBpcyBub3QgYSB2YWxpZCBVUkwnKSk7XG4gIH1cbn07XG5leHBvcnQgeyBwcm9jZXNzT3B0aW9ucywgdmFsaWRhdGVPcHRpb25zIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0T3B0aW9uc1ZhbGlkYXRvci1kaXR0d0w3ZC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJpc1JlYWN0TmF0aXZlIiwibmF2aWdhdG9yIiwicHJvZHVjdCIsImRlZmF1bHRPcHRpb25zIiwidGltZW91dCIsInByb2Nlc3NPcHRpb25zIiwicHJvY2Vzc09wdGlvbnMyIiwib3B0cyIsIm9wdGlvbnMiLCJ1cmwiLCJzZWFyY2hQYXJhbXMiLCJVUkwiLCJub3JtYWxpemVUaW1lb3V0IiwicXVlcnkiLCJrZXkiLCJ2YWx1ZSIsIk9iamVjdCIsImVudHJpZXMiLCJBcnJheSIsImlzQXJyYXkiLCJ2IiwiYXBwZW5kIiwic3BsaXQiLCJzZWFyY2giLCJ0b1N0cmluZyIsImNvbmNhdCIsIm1ldGhvZCIsImJvZHkiLCJ0b1VwcGVyQ2FzZSIsInRpbWUiLCJjb25uZWN0Iiwic29ja2V0IiwiZGVsYXkiLCJOdW1iZXIiLCJpc05hTiIsInZhbGlkVXJsIiwidmFsaWRhdGVPcHRpb25zIiwidmFsaWRhdGVPcHRpb25zMiIsInRlc3QiLCJFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-dittwL7d.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/get-it/dist/index.react-server.js":
/*!********************************************************!*\
  !*** ./node_modules/get-it/dist/index.react-server.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   adapter: () => (/* binding */ adapter),\n/* harmony export */   environment: () => (/* binding */ environment),\n/* harmony export */   getIt: () => (/* binding */ getIt)\n/* harmony export */ });\n/* harmony import */ var _chunks_createRequester_ryeXkh0z_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_chunks/createRequester-ryeXkh0z.js */ \"(rsc)/./node_modules/get-it/dist/_chunks/createRequester-ryeXkh0z.js\");\n/* harmony import */ var parse_headers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! parse-headers */ \"(rsc)/./node_modules/parse-headers/parse-headers.js\");\n\n\nvar __accessCheck = (obj, member, msg)=>{\n    if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter)=>{\n    __accessCheck(obj, member, \"read from private field\");\n    return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value)=>{\n    if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter)=>{\n    __accessCheck(obj, member, \"write to private field\");\n    setter ? setter.call(obj, value) : member.set(obj, value);\n    return value;\n};\nvar _method, _url, _resHeaders, _headers, _controller, _init, _useAbortSignal;\nclass FetchXhr {\n    constructor(){\n        /**\n     * https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/readyState\n     */ this.readyState = 0;\n        this.responseType = \"\";\n        /**\n     * Private implementation details\n     */ __privateAdd(this, _method, void 0);\n        __privateAdd(this, _url, void 0);\n        __privateAdd(this, _resHeaders, void 0);\n        __privateAdd(this, _headers, {});\n        __privateAdd(this, _controller, void 0);\n        __privateAdd(this, _init, {});\n        __privateAdd(this, _useAbortSignal, void 0);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- _async is only declared for typings compatibility\n    open(method, url, _async) {\n        __privateSet(this, _method, method);\n        __privateSet(this, _url, url);\n        __privateSet(this, _resHeaders, \"\");\n        this.readyState = 1;\n        this.onreadystatechange();\n        __privateSet(this, _controller, void 0);\n    }\n    abort() {\n        if (__privateGet(this, _controller)) {\n            __privateGet(this, _controller).abort();\n        }\n    }\n    getAllResponseHeaders() {\n        return __privateGet(this, _resHeaders);\n    }\n    setRequestHeader(name, value) {\n        __privateGet(this, _headers)[name] = value;\n    }\n    // Allow setting extra fetch init options, needed for runtimes such as Vercel Edge to set `cache` and other options in React Server Components\n    setInit(init) {\n        let useAbortSignal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        __privateSet(this, _init, init);\n        __privateSet(this, _useAbortSignal, useAbortSignal);\n    }\n    send(body) {\n        const textBody = this.responseType !== \"arraybuffer\";\n        const options = {\n            ...__privateGet(this, _init),\n            method: __privateGet(this, _method),\n            headers: __privateGet(this, _headers),\n            body\n        };\n        if (typeof AbortController === \"function\" && __privateGet(this, _useAbortSignal)) {\n            __privateSet(this, _controller, new AbortController());\n            if (typeof EventTarget !== \"undefined\" && __privateGet(this, _controller).signal instanceof EventTarget) {\n                options.signal = __privateGet(this, _controller).signal;\n            }\n        }\n        if (typeof document !== \"undefined\") {\n            options.credentials = this.withCredentials ? \"include\" : \"omit\";\n        }\n        fetch(__privateGet(this, _url), options).then((res)=>{\n            res.headers.forEach((value, key)=>{\n                __privateSet(this, _resHeaders, __privateGet(this, _resHeaders) + \"\".concat(key, \": \").concat(value, \"\\r\\n\"));\n            });\n            this.status = res.status;\n            this.statusText = res.statusText;\n            this.readyState = 3;\n            return textBody ? res.text() : res.arrayBuffer();\n        }).then((resBody)=>{\n            if (typeof resBody === \"string\") {\n                this.responseText = resBody;\n            } else {\n                this.response = resBody;\n            }\n            this.readyState = 4;\n            this.onreadystatechange();\n        }).catch((err)=>{\n            var _a;\n            if (err.name === \"AbortError\") {\n                this.onabort();\n                return;\n            }\n            (_a = this.onerror) == null ? void 0 : _a.call(this, err);\n        });\n    }\n}\n_method = new WeakMap();\n_url = new WeakMap();\n_resHeaders = new WeakMap();\n_headers = new WeakMap();\n_controller = new WeakMap();\n_init = new WeakMap();\n_useAbortSignal = new WeakMap();\nconst adapter = typeof XMLHttpRequest === \"function\" ? \"xhr\" : \"fetch\";\nconst XmlHttpRequest = adapter === \"xhr\" ? XMLHttpRequest : FetchXhr;\nconst httpRequester = (context, callback)=>{\n    var _a;\n    const opts = context.options;\n    const options = context.applyMiddleware(\"finalizeOptions\", opts);\n    const timers = {};\n    const injectedResponse = context.applyMiddleware(\"interceptRequest\", void 0, {\n        adapter,\n        context\n    });\n    if (injectedResponse) {\n        const cbTimer = setTimeout(callback, 0, null, injectedResponse);\n        const cancel = ()=>clearTimeout(cbTimer);\n        return {\n            abort: cancel\n        };\n    }\n    let xhr = new XmlHttpRequest();\n    if (xhr instanceof FetchXhr && typeof options.fetch === \"object\") {\n        xhr.setInit(options.fetch, (_a = options.useAbortSignal) != null ? _a : true);\n    }\n    const headers = options.headers;\n    const delays = options.timeout;\n    let aborted = false;\n    let loaded = false;\n    let timedOut = false;\n    xhr.onerror = (event)=>{\n        onError(new Error(\"Request error while attempting to reach \".concat(options.url).concat(event.lengthComputable ? \"(\".concat(event.loaded, \" of \").concat(event.total, \" bytes transferred)\") : \"\")));\n    };\n    xhr.ontimeout = (event)=>{\n        onError(new Error(\"Request timeout while attempting to reach \".concat(options.url).concat(event.lengthComputable ? \"(\".concat(event.loaded, \" of \").concat(event.total, \" bytes transferred)\") : \"\")));\n    };\n    xhr.onabort = ()=>{\n        stopTimers(true);\n        aborted = true;\n    };\n    xhr.onreadystatechange = ()=>{\n        resetTimers();\n        if (aborted || xhr.readyState !== 4) {\n            return;\n        }\n        if (xhr.status === 0) {\n            return;\n        }\n        onLoad();\n    };\n    xhr.open(options.method, options.url, true);\n    xhr.withCredentials = !!options.withCredentials;\n    if (headers && xhr.setRequestHeader) {\n        for(const key in headers){\n            if (headers.hasOwnProperty(key)) {\n                xhr.setRequestHeader(key, headers[key]);\n            }\n        }\n    }\n    if (options.rawBody) {\n        xhr.responseType = \"arraybuffer\";\n    }\n    context.applyMiddleware(\"onRequest\", {\n        options,\n        adapter,\n        request: xhr,\n        context\n    });\n    xhr.send(options.body || null);\n    if (delays) {\n        timers.connect = setTimeout(()=>timeoutRequest(\"ETIMEDOUT\"), delays.connect);\n    }\n    return {\n        abort\n    };\n    function abort() {\n        aborted = true;\n        if (xhr) {\n            xhr.abort();\n        }\n    }\n    function timeoutRequest(code) {\n        timedOut = true;\n        xhr.abort();\n        const error = new Error(code === \"ESOCKETTIMEDOUT\" ? \"Socket timed out on request to \".concat(options.url) : \"Connection timed out on request to \".concat(options.url));\n        error.code = code;\n        context.channels.error.publish(error);\n    }\n    function resetTimers() {\n        if (!delays) {\n            return;\n        }\n        stopTimers();\n        timers.socket = setTimeout(()=>timeoutRequest(\"ESOCKETTIMEDOUT\"), delays.socket);\n    }\n    function stopTimers(force) {\n        if (force || aborted || xhr.readyState >= 2 && timers.connect) {\n            clearTimeout(timers.connect);\n        }\n        if (timers.socket) {\n            clearTimeout(timers.socket);\n        }\n    }\n    function onError(error) {\n        if (loaded) {\n            return;\n        }\n        stopTimers(true);\n        loaded = true;\n        xhr = null;\n        const err = error || new Error(\"Network error while attempting to reach \".concat(options.url));\n        err.isNetworkError = true;\n        err.request = options;\n        callback(err);\n    }\n    function reduceResponse() {\n        return {\n            body: xhr.response || (xhr.responseType === \"\" || xhr.responseType === \"text\" ? xhr.responseText : \"\"),\n            url: options.url,\n            method: options.method,\n            headers: parse_headers__WEBPACK_IMPORTED_MODULE_0__(xhr.getAllResponseHeaders()),\n            statusCode: xhr.status,\n            statusMessage: xhr.statusText\n        };\n    }\n    function onLoad() {\n        if (aborted || loaded || timedOut) {\n            return;\n        }\n        if (xhr.status === 0) {\n            onError(new Error(\"Unknown XHR error\"));\n            return;\n        }\n        stopTimers();\n        loaded = true;\n        callback(null, reduceResponse());\n    }\n};\nconst getIt = function() {\n    let initMiddleware = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let httpRequest = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : httpRequester;\n    return (0,_chunks_createRequester_ryeXkh0z_js__WEBPACK_IMPORTED_MODULE_1__.createRequester)(initMiddleware, httpRequest);\n};\nconst environment = \"react-server\";\n //# sourceMappingURL=index.react-server.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvaW5kZXgucmVhY3Qtc2VydmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXdFO0FBQy9CO0FBQ3pDLElBQUlFLGdCQUFnQixDQUFDQyxLQUFLQyxRQUFRQztJQUNoQyxJQUFJLENBQUNELE9BQU9FLEdBQUcsQ0FBQ0gsTUFBTSxNQUFNSSxVQUFVLFlBQVlGO0FBQ3BEO0FBQ0EsSUFBSUcsZUFBZSxDQUFDTCxLQUFLQyxRQUFRSztJQUMvQlAsY0FBY0MsS0FBS0MsUUFBUTtJQUMzQixPQUFPSyxTQUFTQSxPQUFPQyxJQUFJLENBQUNQLE9BQU9DLE9BQU9PLEdBQUcsQ0FBQ1I7QUFDaEQ7QUFDQSxJQUFJUyxlQUFlLENBQUNULEtBQUtDLFFBQVFTO0lBQy9CLElBQUlULE9BQU9FLEdBQUcsQ0FBQ0gsTUFBTSxNQUFNSSxVQUFVO0lBQ3JDSCxrQkFBa0JVLFVBQVVWLE9BQU9XLEdBQUcsQ0FBQ1osT0FBT0MsT0FBT1ksR0FBRyxDQUFDYixLQUFLVTtBQUNoRTtBQUNBLElBQUlJLGVBQWUsQ0FBQ2QsS0FBS0MsUUFBUVMsT0FBT0s7SUFDdENoQixjQUFjQyxLQUFLQyxRQUFRO0lBQzNCYyxTQUFTQSxPQUFPUixJQUFJLENBQUNQLEtBQUtVLFNBQVNULE9BQU9ZLEdBQUcsQ0FBQ2IsS0FBS1U7SUFDbkQsT0FBT0E7QUFDVDtBQUNBLElBQUlNLFNBQVNDLE1BQU1DLGFBQWFDLFVBQVVDLGFBQWFDLE9BQU9DO0FBQzlELE1BQU1DO0lBQ0pDLGFBQWM7UUFDWjs7S0FFQyxHQUNELElBQUksQ0FBQ0MsVUFBVSxHQUFHO1FBQ2xCLElBQUksQ0FBQ0MsWUFBWSxHQUFHO1FBQ3BCOztLQUVDLEdBQ0RqQixhQUFhLElBQUksRUFBRU8sU0FBUyxLQUFLO1FBQ2pDUCxhQUFhLElBQUksRUFBRVEsTUFBTSxLQUFLO1FBQzlCUixhQUFhLElBQUksRUFBRVMsYUFBYSxLQUFLO1FBQ3JDVCxhQUFhLElBQUksRUFBRVUsVUFB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QWMvRSxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBR29DO0lBQ3RGLE9BQU85RSxvRkFBZUEsQ0FBQ3dILGdCQUFnQkM7QUFDekM7QUFDQSxNQUFNQyxjQUFjO0FBQ21CLENBQ3ZDLDhDQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1jb21tZXJjZS15dC1ieS1taWtlLy4vbm9kZV9tb2R1bGVzL2dldC1pdC9kaXN0L2luZGV4LnJlYWN0LXNlcnZlci5qcz80YmQyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVJlcXVlc3RlciB9IGZyb20gJy4vX2NodW5rcy9jcmVhdGVSZXF1ZXN0ZXItcnllWGtoMHouanMnO1xuaW1wb3J0IHBhcnNlSGVhZGVycyBmcm9tICdwYXJzZS1oZWFkZXJzJztcbnZhciBfX2FjY2Vzc0NoZWNrID0gKG9iaiwgbWVtYmVyLCBtc2cpID0+IHtcbiAgaWYgKCFtZW1iZXIuaGFzKG9iaikpIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBcIiArIG1zZyk7XG59O1xudmFyIF9fcHJpdmF0ZUdldCA9IChvYmosIG1lbWJlciwgZ2V0dGVyKSA9PiB7XG4gIF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIik7XG4gIHJldHVybiBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogbWVtYmVyLmdldChvYmopO1xufTtcbnZhciBfX3ByaXZhdGVBZGQgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiB7XG4gIGlmIChtZW1iZXIuaGFzKG9iaikpIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIik7XG4gIG1lbWJlciBpbnN0YW5jZW9mIFdlYWtTZXQgPyBtZW1iZXIuYWRkKG9iaikgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xufTtcbnZhciBfX3ByaXZhdGVTZXQgPSAob2JqLCBtZW1iZXIsIHZhbHVlLCBzZXR0ZXIpID0+IHtcbiAgX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJ3cml0ZSB0byBwcml2YXRlIGZpZWxkXCIpO1xuICBzZXR0ZXIgPyBzZXR0ZXIuY2FsbChvYmosIHZhbHVlKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG52YXIgX21ldGhvZCwgX3VybCwgX3Jlc0hlYWRlcnMsIF9oZWFkZXJzLCBfY29udHJvbGxlciwgX2luaXQsIF91c2VBYm9ydFNpZ25hbDtcbmNsYXNzIEZldGNoWGhyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqXG4gICAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1hNTEh0dHBSZXF1ZXN0L3JlYWR5U3RhdGVcbiAgICAgKi9cbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAwO1xuICAgIHRoaXMucmVzcG9uc2VUeXBlID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBQcml2YXRlIGltcGxlbWVudGF0aW9uIGRldGFpbHNcbiAgICAgKi9cbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX21ldGhvZCwgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3VybCwgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3Jlc0hlYWRlcnMsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9oZWFkZXJzLCB7fSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9jb250cm9sbGVyLCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaW5pdCwge30pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfdXNlQWJvcnRTaWduYWwsIHZvaWQgMCk7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAtLSBfYXN5bmMgaXMgb25seSBkZWNsYXJlZCBmb3IgdHlwaW5ncyBjb21wYXRpYmlsaXR5XG4gIG9wZW4obWV0aG9kLCB1cmwsIF9hc3luYykge1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfbWV0aG9kLCBtZXRob2QpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfdXJsLCB1cmwpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfcmVzSGVhZGVycywgXCJcIik7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gMTtcbiAgICB0aGlzLm9ucmVhZHlzdGF0ZWNoYW5nZSgpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfY29udHJvbGxlciwgdm9pZCAwKTtcbiAgfVxuICBhYm9ydCgpIHtcbiAgICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9jb250cm9sbGVyKSkge1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9jb250cm9sbGVyKS5hYm9ydCgpO1xuICAgIH1cbiAgfVxuICBnZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfcmVzSGVhZGVycyk7XG4gIH1cbiAgc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSkge1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGVhZGVycylbbmFtZV0gPSB2YWx1ZTtcbiAgfVxuICAvLyBBbGxvdyBzZXR0aW5nIGV4dHJhIGZldGNoIGluaXQgb3B0aW9ucywgbmVlZGVkIGZvciBydW50aW1lcyBzdWNoIGFzIFZlcmNlbCBFZGdlIHRvIHNldCBgY2FjaGVgIGFuZCBvdGhlciBvcHRpb25zIGluIFJlYWN0IFNlcnZlciBDb21wb25lbnRzXG4gIHNldEluaXQoaW5pdCkge1xuICAgIGxldCB1c2VBYm9ydFNpZ25hbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2luaXQsIGluaXQpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfdXNlQWJvcnRTaWduYWwsIHVzZUFib3J0U2lnbmFsKTtcbiAgfVxuICBzZW5kKGJvZHkpIHtcbiAgICBjb25zdCB0ZXh0Qm9keSA9IHRoaXMucmVzcG9uc2VUeXBlICE9PSBcImFycmF5YnVmZmVyXCI7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIC4uLl9fcHJpdmF0ZUdldCh0aGlzLCBfaW5pdCksXG4gICAgICBtZXRob2Q6IF9fcHJpdmF0ZUdldCh0aGlzLCBfbWV0aG9kKSxcbiAgICAgIGhlYWRlcnM6IF9fcHJpdmF0ZUdldCh0aGlzLCBfaGVhZGVycyksXG4gICAgICBib2R5XG4gICAgfTtcbiAgICBpZiAodHlwZW9mIEFib3J0Q29udHJvbGxlciA9PT0gXCJmdW5jdGlvblwiICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfdXNlQWJvcnRTaWduYWwpKSB7XG4gICAgICBfX3ByaXZhdGVTZXQodGhpcywgX2NvbnRyb2xsZXIsIG5ldyBBYm9ydENvbnRyb2xsZXIoKSk7XG4gICAgICBpZiAodHlwZW9mIEV2ZW50VGFyZ2V0ICE9PSBcInVuZGVmaW5lZFwiICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfY29udHJvbGxlcikuc2lnbmFsIGluc3RhbmNlb2YgRXZlbnRUYXJnZXQpIHtcbiAgICAgICAgb3B0aW9ucy5zaWduYWwgPSBfX3ByaXZhdGVHZXQodGhpcywgX2NvbnRyb2xsZXIpLnNpZ25hbDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgb3B0aW9ucy5jcmVkZW50aWFscyA9IHRoaXMud2l0aENyZWRlbnRpYWxzID8gXCJpbmNsdWRlXCIgOiBcIm9taXRcIjtcbiAgICB9XG4gICAgZmV0Y2goX19wcml2YXRlR2V0KHRoaXMsIF91cmwpLCBvcHRpb25zKS50aGVuKHJlcyA9PiB7XG4gICAgICByZXMuaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfcmVzSGVhZGVycywgX19wcml2YXRlR2V0KHRoaXMsIF9yZXNIZWFkZXJzKSArIFwiXCIuY29uY2F0KGtleSwgXCI6IFwiKS5jb25jYXQodmFsdWUsIFwiXFxyXFxuXCIpKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zdGF0dXMgPSByZXMuc3RhdHVzO1xuICAgICAgdGhpcy5zdGF0dXNUZXh0ID0gcmVzLnN0YXR1c1RleHQ7XG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPSAzO1xuICAgICAgcmV0dXJuIHRleHRCb2R5ID8gcmVzLnRleHQoKSA6IHJlcy5hcnJheUJ1ZmZlcigpO1xuICAgIH0pLnRoZW4ocmVzQm9keSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHJlc0JvZHkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhpcy5yZXNwb25zZVRleHQgPSByZXNCb2R5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IHJlc0JvZHk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPSA0O1xuICAgICAgdGhpcy5vbnJlYWR5c3RhdGVjaGFuZ2UoKTtcbiAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKGVyci5uYW1lID09PSBcIkFib3J0RXJyb3JcIikge1xuICAgICAgICB0aGlzLm9uYWJvcnQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgKF9hID0gdGhpcy5vbmVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBlcnIpO1xuICAgIH0pO1xuICB9XG59XG5fbWV0aG9kID0gbmV3IFdlYWtNYXAoKTtcbl91cmwgPSBuZXcgV2Vha01hcCgpO1xuX3Jlc0hlYWRlcnMgPSBuZXcgV2Vha01hcCgpO1xuX2hlYWRlcnMgPSBuZXcgV2Vha01hcCgpO1xuX2NvbnRyb2xsZXIgPSBuZXcgV2Vha01hcCgpO1xuX2luaXQgPSBuZXcgV2Vha01hcCgpO1xuX3VzZUFib3J0U2lnbmFsID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IGFkYXB0ZXIgPSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgPT09IFwiZnVuY3Rpb25cIiA/IFwieGhyXCIgOiBcImZldGNoXCI7XG5jb25zdCBYbWxIdHRwUmVxdWVzdCA9IGFkYXB0ZXIgPT09IFwieGhyXCIgPyBYTUxIdHRwUmVxdWVzdCA6IEZldGNoWGhyO1xuY29uc3QgaHR0cFJlcXVlc3RlciA9IChjb250ZXh0LCBjYWxsYmFjaykgPT4ge1xuICB2YXIgX2E7XG4gIGNvbnN0IG9wdHMgPSBjb250ZXh0Lm9wdGlvbnM7XG4gIGNvbnN0IG9wdGlvbnMgPSBjb250ZXh0LmFwcGx5TWlkZGxld2FyZShcImZpbmFsaXplT3B0aW9uc1wiLCBvcHRzKTtcbiAgY29uc3QgdGltZXJzID0ge307XG4gIGNvbnN0IGluamVjdGVkUmVzcG9uc2UgPSBjb250ZXh0LmFwcGx5TWlkZGxld2FyZShcImludGVyY2VwdFJlcXVlc3RcIiwgdm9pZCAwLCB7XG4gICAgYWRhcHRlcixcbiAgICBjb250ZXh0XG4gIH0pO1xuICBpZiAoaW5qZWN0ZWRSZXNwb25zZSkge1xuICAgIGNvbnN0IGNiVGltZXIgPSBzZXRUaW1lb3V0KGNhbGxiYWNrLCAwLCBudWxsLCBpbmplY3RlZFJlc3BvbnNlKTtcbiAgICBjb25zdCBjYW5jZWwgPSAoKSA9PiBjbGVhclRpbWVvdXQoY2JUaW1lcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFib3J0OiBjYW5jZWxcbiAgICB9O1xuICB9XG4gIGxldCB4aHIgPSBuZXcgWG1sSHR0cFJlcXVlc3QoKTtcbiAgaWYgKHhociBpbnN0YW5jZW9mIEZldGNoWGhyICYmIHR5cGVvZiBvcHRpb25zLmZldGNoID09PSBcIm9iamVjdFwiKSB7XG4gICAgeGhyLnNldEluaXQob3B0aW9ucy5mZXRjaCwgKF9hID0gb3B0aW9ucy51c2VBYm9ydFNpZ25hbCkgIT0gbnVsbCA/IF9hIDogdHJ1ZSk7XG4gIH1cbiAgY29uc3QgaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycztcbiAgY29uc3QgZGVsYXlzID0gb3B0aW9ucy50aW1lb3V0O1xuICBsZXQgYWJvcnRlZCA9IGZhbHNlO1xuICBsZXQgbG9hZGVkID0gZmFsc2U7XG4gIGxldCB0aW1lZE91dCA9IGZhbHNlO1xuICB4aHIub25lcnJvciA9IGV2ZW50ID0+IHtcbiAgICBvbkVycm9yKG5ldyBFcnJvcihcIlJlcXVlc3QgZXJyb3Igd2hpbGUgYXR0ZW1wdGluZyB0byByZWFjaCBcIi5jb25jYXQob3B0aW9ucy51cmwpLmNvbmNhdChldmVudC5sZW5ndGhDb21wdXRhYmxlID8gXCIoXCIuY29uY2F0KGV2ZW50LmxvYWRlZCwgXCIgb2YgXCIpLmNvbmNhdChldmVudC50b3RhbCwgXCIgYnl0ZXMgdHJhbnNmZXJyZWQpXCIpIDogXCJcIikpKTtcbiAgfTtcbiAgeGhyLm9udGltZW91dCA9IGV2ZW50ID0+IHtcbiAgICBvbkVycm9yKG5ldyBFcnJvcihcIlJlcXVlc3QgdGltZW91dCB3aGlsZSBhdHRlbXB0aW5nIHRvIHJlYWNoIFwiLmNvbmNhdChvcHRpb25zLnVybCkuY29uY2F0KGV2ZW50Lmxlbmd0aENvbXB1dGFibGUgPyBcIihcIi5jb25jYXQoZXZlbnQubG9hZGVkLCBcIiBvZiBcIikuY29uY2F0KGV2ZW50LnRvdGFsLCBcIiBieXRlcyB0cmFuc2ZlcnJlZClcIikgOiBcIlwiKSkpO1xuICB9O1xuICB4aHIub25hYm9ydCA9ICgpID0+IHtcbiAgICBzdG9wVGltZXJzKHRydWUpO1xuICAgIGFib3J0ZWQgPSB0cnVlO1xuICB9O1xuICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgIHJlc2V0VGltZXJzKCk7XG4gICAgaWYgKGFib3J0ZWQgfHwgeGhyLnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHhoci5zdGF0dXMgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgb25Mb2FkKCk7XG4gIH07XG4gIHhoci5vcGVuKG9wdGlvbnMubWV0aG9kLCBvcHRpb25zLnVybCwgdHJ1ZVxuICAvLyBBbHdheXMgYXN5bmNcbiAgKTtcblxuICB4aHIud2l0aENyZWRlbnRpYWxzID0gISFvcHRpb25zLndpdGhDcmVkZW50aWFscztcbiAgaWYgKGhlYWRlcnMgJiYgeGhyLnNldFJlcXVlc3RIZWFkZXIpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBoZWFkZXJzKSB7XG4gICAgICBpZiAoaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgaGVhZGVyc1trZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMucmF3Qm9keSkge1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG4gIH1cbiAgY29udGV4dC5hcHBseU1pZGRsZXdhcmUoXCJvblJlcXVlc3RcIiwge1xuICAgIG9wdGlvbnMsXG4gICAgYWRhcHRlcixcbiAgICByZXF1ZXN0OiB4aHIsXG4gICAgY29udGV4dFxuICB9KTtcbiAgeGhyLnNlbmQob3B0aW9ucy5ib2R5IHx8IG51bGwpO1xuICBpZiAoZGVsYXlzKSB7XG4gICAgdGltZXJzLmNvbm5lY3QgPSBzZXRUaW1lb3V0KCgpID0+IHRpbWVvdXRSZXF1ZXN0KFwiRVRJTUVET1VUXCIpLCBkZWxheXMuY29ubmVjdCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBhYm9ydFxuICB9O1xuICBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICBpZiAoeGhyKSB7XG4gICAgICB4aHIuYWJvcnQoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdGltZW91dFJlcXVlc3QoY29kZSkge1xuICAgIHRpbWVkT3V0ID0gdHJ1ZTtcbiAgICB4aHIuYWJvcnQoKTtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihjb2RlID09PSBcIkVTT0NLRVRUSU1FRE9VVFwiID8gXCJTb2NrZXQgdGltZWQgb3V0IG9uIHJlcXVlc3QgdG8gXCIuY29uY2F0KG9wdGlvbnMudXJsKSA6IFwiQ29ubmVjdGlvbiB0aW1lZCBvdXQgb24gcmVxdWVzdCB0byBcIi5jb25jYXQob3B0aW9ucy51cmwpKTtcbiAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgICBjb250ZXh0LmNoYW5uZWxzLmVycm9yLnB1Ymxpc2goZXJyb3IpO1xuICB9XG4gIGZ1bmN0aW9uIHJlc2V0VGltZXJzKCkge1xuICAgIGlmICghZGVsYXlzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0b3BUaW1lcnMoKTtcbiAgICB0aW1lcnMuc29ja2V0ID0gc2V0VGltZW91dCgoKSA9PiB0aW1lb3V0UmVxdWVzdChcIkVTT0NLRVRUSU1FRE9VVFwiKSwgZGVsYXlzLnNvY2tldCk7XG4gIH1cbiAgZnVuY3Rpb24gc3RvcFRpbWVycyhmb3JjZSkge1xuICAgIGlmIChmb3JjZSB8fCBhYm9ydGVkIHx8IHhoci5yZWFkeVN0YXRlID49IDIgJiYgdGltZXJzLmNvbm5lY3QpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcnMuY29ubmVjdCk7XG4gICAgfVxuICAgIGlmICh0aW1lcnMuc29ja2V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJzLnNvY2tldCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG9uRXJyb3IoZXJyb3IpIHtcbiAgICBpZiAobG9hZGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0b3BUaW1lcnModHJ1ZSk7XG4gICAgbG9hZGVkID0gdHJ1ZTtcbiAgICB4aHIgPSBudWxsO1xuICAgIGNvbnN0IGVyciA9IGVycm9yIHx8IG5ldyBFcnJvcihcIk5ldHdvcmsgZXJyb3Igd2hpbGUgYXR0ZW1wdGluZyB0byByZWFjaCBcIi5jb25jYXQob3B0aW9ucy51cmwpKTtcbiAgICBlcnIuaXNOZXR3b3JrRXJyb3IgPSB0cnVlO1xuICAgIGVyci5yZXF1ZXN0ID0gb3B0aW9ucztcbiAgICBjYWxsYmFjayhlcnIpO1xuICB9XG4gIGZ1bmN0aW9uIHJlZHVjZVJlc3BvbnNlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBib2R5OiB4aHIucmVzcG9uc2UgfHwgKHhoci5yZXNwb25zZVR5cGUgPT09IFwiXCIgfHwgeGhyLnJlc3BvbnNlVHlwZSA9PT0gXCJ0ZXh0XCIgPyB4aHIucmVzcG9uc2VUZXh0IDogXCJcIiksXG4gICAgICB1cmw6IG9wdGlvbnMudXJsLFxuICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgIGhlYWRlcnM6IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpLFxuICAgICAgc3RhdHVzQ29kZTogeGhyLnN0YXR1cyxcbiAgICAgIHN0YXR1c01lc3NhZ2U6IHhoci5zdGF0dXNUZXh0XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBvbkxvYWQoKSB7XG4gICAgaWYgKGFib3J0ZWQgfHwgbG9hZGVkIHx8IHRpbWVkT3V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh4aHIuc3RhdHVzID09PSAwKSB7XG4gICAgICBvbkVycm9yKG5ldyBFcnJvcihcIlVua25vd24gWEhSIGVycm9yXCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RvcFRpbWVycygpO1xuICAgIGxvYWRlZCA9IHRydWU7XG4gICAgY2FsbGJhY2sobnVsbCwgcmVkdWNlUmVzcG9uc2UoKSk7XG4gIH1cbn07XG5jb25zdCBnZXRJdCA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IGluaXRNaWRkbGV3YXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgbGV0IGh0dHBSZXF1ZXN0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBodHRwUmVxdWVzdGVyO1xuICByZXR1cm4gY3JlYXRlUmVxdWVzdGVyKGluaXRNaWRkbGV3YXJlLCBodHRwUmVxdWVzdCk7XG59O1xuY29uc3QgZW52aXJvbm1lbnQgPSBcInJlYWN0LXNlcnZlclwiO1xuZXhwb3J0IHsgYWRhcHRlciwgZW52aXJvbm1lbnQsIGdldEl0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5yZWFjdC1zZXJ2ZXIuanMubWFwXG4iXSwibmFtZXMiOlsiY3JlYXRlUmVxdWVzdGVyIiwicGFyc2VIZWFkZXJzIiwiX19hY2Nlc3NDaGVjayIsIm9iaiIsIm1lbWJlciIsIm1zZyIsImhhcyIsIlR5cGVFcnJvciIsIl9fcHJpdmF0ZUdldCIsImdldHRlciIsImNhbGwiLCJnZXQiLCJfX3ByaXZhdGVBZGQiLCJ2YWx1ZSIsIldlYWtTZXQiLCJhZGQiLCJzZXQiLCJfX3ByaXZhdGVTZXQiLCJzZXR0ZXIiLCJfbWV0aG9kIiwiX3VybCIsIl9yZXNIZWFkZXJzIiwiX2hlYWRlcnMiLCJfY29udHJvbGxlciIsIl9pbml0IiwiX3VzZUFib3J0U2lnbmFsIiwiRmV0Y2hYaHIiLCJjb25zdHJ1Y3RvciIsInJlYWR5U3RhdGUiLCJyZXNwb25zZVR5cGUiLCJvcGVuIiwibWV0aG9kIiwidXJsIiwiX2FzeW5jIiwib25yZWFkeXN0YXRlY2hhbmdlIiwiYWJvcnQiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJzZXRSZXF1ZXN0SGVhZGVyIiwibmFtZSIsInNldEluaXQiLCJpbml0IiwidXNlQWJvcnRTaWduYWwiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJzZW5kIiwiYm9keSIsInRleHRCb2R5Iiwib3B0aW9ucyIsImhlYWRlcnMiLCJBYm9ydENvbnRyb2xsZXIiLCJFdmVudFRhcmdldCIsInNpZ25hbCIsImRvY3VtZW50IiwiY3JlZGVudGlhbHMiLCJ3aXRoQ3JlZGVudGlhbHMiLCJmZXRjaCIsInRoZW4iLCJyZXMiLCJmb3JFYWNoIiwia2V5IiwiY29uY2F0Iiwic3RhdHVzIiwic3RhdHVzVGV4dCIsInRleHQiLCJhcnJheUJ1ZmZlciIsInJlc0JvZHkiLCJyZXNwb25zZVRleHQiLCJyZXNwb25zZSIsImNhdGNoIiwiZXJyIiwiX2EiLCJvbmFib3J0Iiwib25lcnJvciIsIldlYWtNYXAiLCJhZGFwdGVyIiwiWE1MSHR0cFJlcXVlc3QiLCJYbWxIdHRwUmVxdWVzdCIsImh0dHBSZXF1ZXN0ZXIiLCJjb250ZXh0IiwiY2FsbGJhY2siLCJvcHRzIiwiYXBwbHlNaWRkbGV3YXJlIiwidGltZXJzIiwiaW5qZWN0ZWRSZXNwb25zZSIsImNiVGltZXIiLCJzZXRUaW1lb3V0IiwiY2FuY2VsIiwiY2xlYXJUaW1lb3V0IiwieGhyIiwiZGVsYXlzIiwidGltZW91dCIsImFib3J0ZWQiLCJsb2FkZWQiLCJ0aW1lZE91dCIsImV2ZW50Iiwib25FcnJvciIsIkVycm9yIiwibGVuZ3RoQ29tcHV0YWJsZSIsInRvdGFsIiwib250aW1lb3V0Iiwic3RvcFRpbWVycyIsInJlc2V0VGltZXJzIiwib25Mb2FkIiwiaGFzT3duUHJvcGVydHkiLCJyYXdCb2R5IiwicmVxdWVzdCIsImNvbm5lY3QiLCJ0aW1lb3V0UmVxdWVzdCIsImNvZGUiLCJlcnJvciIsImNoYW5uZWxzIiwicHVibGlzaCIsInNvY2tldCIsImZvcmNlIiwiaXNOZXR3b3JrRXJyb3IiLCJyZWR1Y2VSZXNwb25zZSIsInN0YXR1c0NvZGUiLCJzdGF0dXNNZXNzYWdlIiwiZ2V0SXQiLCJpbml0TWlkZGxld2FyZSIsImh0dHBSZXF1ZXN0IiwiZW52aXJvbm1lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/get-it/dist/index.react-server.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/get-it/dist/middleware.browser.js":
/*!********************************************************!*\
  !*** ./node_modules/get-it/dist/middleware.browser.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cancel: () => (/* binding */ Cancel),\n/* harmony export */   CancelToken: () => (/* binding */ CancelToken),\n/* harmony export */   agent: () => (/* binding */ agent),\n/* harmony export */   base: () => (/* binding */ base),\n/* harmony export */   debug: () => (/* binding */ debug),\n/* harmony export */   headers: () => (/* binding */ headers),\n/* harmony export */   httpErrors: () => (/* binding */ httpErrors),\n/* harmony export */   injectResponse: () => (/* binding */ injectResponse),\n/* harmony export */   jsonRequest: () => (/* binding */ jsonRequest),\n/* harmony export */   jsonResponse: () => (/* binding */ jsonResponse),\n/* harmony export */   keepAlive: () => (/* binding */ keepAlive),\n/* harmony export */   mtls: () => (/* binding */ mtls),\n/* harmony export */   observable: () => (/* binding */ observable),\n/* harmony export */   processOptions: () => (/* reexport safe */ _chunks_defaultOptionsValidator_dittwL7d_js__WEBPACK_IMPORTED_MODULE_1__.processOptions),\n/* harmony export */   progress: () => (/* binding */ progress),\n/* harmony export */   promise: () => (/* binding */ promise),\n/* harmony export */   proxy: () => (/* binding */ proxy),\n/* harmony export */   retry: () => (/* binding */ retry),\n/* harmony export */   urlEncoded: () => (/* binding */ urlEncoded),\n/* harmony export */   validateOptions: () => (/* reexport safe */ _chunks_defaultOptionsValidator_dittwL7d_js__WEBPACK_IMPORTED_MODULE_1__.validateOptions)\n/* harmony export */ });\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\");\n/* harmony import */ var _chunks_defaultOptionsValidator_dittwL7d_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_chunks/defaultOptionsValidator-dittwL7d.js */ \"(rsc)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-dittwL7d.js\");\n/* harmony import */ var is_plain_object__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! is-plain-object */ \"(rsc)/./node_modules/is-plain-object/dist/is-plain-object.mjs\");\n\n\n\nfunction agent(opts) {\n    return {};\n}\nconst leadingSlash = /^\\//;\nconst trailingSlash = /\\/$/;\nfunction base(baseUrl) {\n    const baseUri = baseUrl.replace(trailingSlash, \"\");\n    return {\n        processOptions: (options)=>{\n            if (/^https?:\\/\\//i.test(options.url)) {\n                return options;\n            }\n            const url = [\n                baseUri,\n                options.url.replace(leadingSlash, \"\")\n            ].join(\"/\");\n            return Object.assign({}, options, {\n                url\n            });\n        }\n    };\n}\nconst SENSITIVE_HEADERS = [\n    \"cookie\",\n    \"authorization\"\n];\nconst hasOwn = Object.prototype.hasOwnProperty;\nconst redactKeys = (source, redacted)=>{\n    const target = {};\n    for(const key in source){\n        if (hasOwn.call(source, key)) {\n            target[key] = redacted.indexOf(key.toLowerCase()) > -1 ? \"<redacted>\" : source[key];\n        }\n    }\n    return target;\n};\nfunction debug() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const verbose = opts.verbose;\n    const namespace = opts.namespace || \"get-it\";\n    const defaultLogger = debug__WEBPACK_IMPORTED_MODULE_0__(namespace);\n    const log = opts.log || defaultLogger;\n    const shortCircuit = log === defaultLogger && !debug__WEBPACK_IMPORTED_MODULE_0__.enabled(namespace);\n    let requestId = 0;\n    return {\n        processOptions: (options)=>{\n            options.debug = log;\n            options.requestId = options.requestId || ++requestId;\n            return options;\n        },\n        onRequest: (event)=>{\n            if (shortCircuit || !event) {\n                return event;\n            }\n            const options = event.options;\n            log(\"[%s] HTTP %s %s\", options.requestId, options.method, options.url);\n            if (verbose && options.body && typeof options.body === \"string\") {\n                log(\"[%s] Request body: %s\", options.requestId, options.body);\n            }\n            if (verbose && options.headers) {\n                const headers = opts.redactSensitiveHeaders === false ? options.headers : redactKeys(options.headers, SENSITIVE_HEADERS);\n                log(\"[%s] Request headers: %s\", options.requestId, JSON.stringify(headers, null, 2));\n            }\n            return event;\n        },\n        onResponse: (res, context)=>{\n            if (shortCircuit || !res) {\n                return res;\n            }\n            const reqId = context.options.requestId;\n            log(\"[%s] Response code: %s %s\", reqId, res.statusCode, res.statusMessage);\n            if (verbose && res.body) {\n                log(\"[%s] Response body: %s\", reqId, stringifyBody(res));\n            }\n            return res;\n        },\n        onError: (err, context)=>{\n            const reqId = context.options.requestId;\n            if (!err) {\n                log(\"[%s] Error encountered, but handled by an earlier middleware\", reqId);\n                return err;\n            }\n            log(\"[%s] ERROR: %s\", reqId, err.message);\n            return err;\n        }\n    };\n}\nfunction stringifyBody(res) {\n    const contentType = (res.headers[\"content-type\"] || \"\").toLowerCase();\n    const isJson = contentType.indexOf(\"application/json\") !== -1;\n    return isJson ? tryFormat(res.body) : res.body;\n}\nfunction tryFormat(body) {\n    try {\n        const parsed = typeof body === \"string\" ? JSON.parse(body) : body;\n        return JSON.stringify(parsed, null, 2);\n    } catch (err) {\n        return body;\n    }\n}\nfunction headers(_headers) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return {\n        processOptions: (options)=>{\n            const existing = options.headers || {};\n            options.headers = opts.override ? Object.assign({}, existing, _headers) : Object.assign({}, _headers, existing);\n            return options;\n        }\n    };\n}\nclass HttpError extends Error {\n    constructor(res, ctx){\n        super();\n        const truncatedUrl = res.url.length > 400 ? \"\".concat(res.url.slice(0, 399), \"…\") : res.url;\n        let msg = \"\".concat(res.method, \"-request to \").concat(truncatedUrl, \" resulted in \");\n        msg += \"HTTP \".concat(res.statusCode, \" \").concat(res.statusMessage);\n        this.message = msg.trim();\n        this.response = res;\n        this.request = ctx.options;\n    }\n}\nfunction httpErrors() {\n    return {\n        onResponse: (res, ctx)=>{\n            const isHttpError = res.statusCode >= 400;\n            if (!isHttpError) {\n                return res;\n            }\n            throw new HttpError(res, ctx);\n        }\n    };\n}\nfunction injectResponse() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (typeof opts.inject !== \"function\") {\n        throw new Error(\"`injectResponse` middleware requires a `inject` function\");\n    }\n    const inject = function inject2(prevValue, event) {\n        const response = opts.inject(event, prevValue);\n        if (!response) {\n            return prevValue;\n        }\n        const options = event.context.options;\n        return {\n            body: \"\",\n            url: options.url,\n            method: options.method,\n            headers: {},\n            statusCode: 200,\n            statusMessage: \"OK\",\n            ...response\n        };\n    };\n    return {\n        interceptRequest: inject\n    };\n}\nconst isBuffer = typeof Buffer === \"undefined\" ? ()=>false : (obj)=>Buffer.isBuffer(obj);\nconst serializeTypes = [\n    \"boolean\",\n    \"string\",\n    \"number\"\n];\nfunction jsonRequest() {\n    return {\n        processOptions: (options)=>{\n            const body = options.body;\n            if (!body) {\n                return options;\n            }\n            const isStream = typeof body.pipe === \"function\";\n            const shouldSerialize = !isStream && !isBuffer(body) && (serializeTypes.indexOf(typeof body) !== -1 || Array.isArray(body) || (0,is_plain_object__WEBPACK_IMPORTED_MODULE_2__.isPlainObject)(body));\n            if (!shouldSerialize) {\n                return options;\n            }\n            return Object.assign({}, options, {\n                body: JSON.stringify(options.body),\n                headers: Object.assign({}, options.headers, {\n                    \"Content-Type\": \"application/json\"\n                })\n            });\n        }\n    };\n}\nfunction jsonResponse(opts) {\n    return {\n        onResponse: (response)=>{\n            const contentType = response.headers[\"content-type\"] || \"\";\n            const shouldDecode = opts && opts.force || contentType.indexOf(\"application/json\") !== -1;\n            if (!response.body || !contentType || !shouldDecode) {\n                return response;\n            }\n            return Object.assign({}, response, {\n                body: tryParse(response.body)\n            });\n        },\n        processOptions: (options)=>Object.assign({}, options, {\n                headers: Object.assign({\n                    Accept: \"application/json\"\n                }, options.headers)\n            })\n    };\n    function tryParse(body) {\n        try {\n            return JSON.parse(body);\n        } catch (err) {\n            err.message = \"Failed to parsed response body as JSON: \".concat(err.message);\n            throw err;\n        }\n    }\n}\nfunction isBrowserOptions(options) {\n    return typeof options === \"object\" && options !== null && !(\"protocol\" in options);\n}\nfunction mtls() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!config.ca) {\n        throw new Error('Required mtls option \"ca\" is missing');\n    }\n    if (!config.cert) {\n        throw new Error('Required mtls option \"cert\" is missing');\n    }\n    if (!config.key) {\n        throw new Error('Required mtls option \"key\" is missing');\n    }\n    return {\n        finalizeOptions: (options)=>{\n            if (isBrowserOptions(options)) {\n                return options;\n            }\n            const mtlsOpts = {\n                cert: config.cert,\n                key: config.key,\n                ca: config.ca\n            };\n            return Object.assign({}, options, mtlsOpts);\n        }\n    };\n}\nlet actualGlobal = {};\nif (typeof globalThis !== \"undefined\") {\n    actualGlobal = globalThis;\n} else if (false) {} else if (typeof global !== \"undefined\") {\n    actualGlobal = global;\n} else if (typeof self !== \"undefined\") {\n    actualGlobal = self;\n}\nvar global$1 = actualGlobal;\nfunction observable() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const Observable = // eslint-disable-next-line @typescript-eslint/no-explicit-any -- @TODO consider dropping checking for a global Observable since it's not on a standards track\n    opts.implementation || global$1.Observable;\n    if (!Observable) {\n        throw new Error(\"`Observable` is not available in global scope, and no implementation was passed\");\n    }\n    return {\n        onReturn: (channels, context)=>new Observable((observer)=>{\n                channels.error.subscribe((err)=>observer.error(err));\n                channels.progress.subscribe((event)=>observer.next(Object.assign({\n                        type: \"progress\"\n                    }, event)));\n                channels.response.subscribe((response)=>{\n                    observer.next(Object.assign({\n                        type: \"response\"\n                    }, response));\n                    observer.complete();\n                });\n                channels.request.publish(context);\n                return ()=>channels.abort.publish();\n            })\n    };\n}\nfunction progress() {\n    return {\n        onRequest: (evt)=>{\n            if (evt.adapter !== \"xhr\") {\n                return;\n            }\n            const xhr = evt.request;\n            const context = evt.context;\n            if (\"upload\" in xhr && \"onprogress\" in xhr.upload) {\n                xhr.upload.onprogress = handleProgress(\"upload\");\n            }\n            if (\"onprogress\" in xhr) {\n                xhr.onprogress = handleProgress(\"download\");\n            }\n            function handleProgress(stage) {\n                return (event)=>{\n                    const percent = event.lengthComputable ? event.loaded / event.total * 100 : -1;\n                    context.channels.progress.publish({\n                        stage,\n                        percent,\n                        total: event.total,\n                        loaded: event.loaded,\n                        lengthComputable: event.lengthComputable\n                    });\n                };\n            }\n        }\n    };\n}\nconst promise = function() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const PromiseImplementation = options.implementation || Promise;\n    if (!PromiseImplementation) {\n        throw new Error(\"`Promise` is not available in global scope, and no implementation was passed\");\n    }\n    return {\n        onReturn: (channels, context)=>new PromiseImplementation((resolve, reject)=>{\n                const cancel = context.options.cancelToken;\n                if (cancel) {\n                    cancel.promise.then((reason)=>{\n                        channels.abort.publish(reason);\n                        reject(reason);\n                    });\n                }\n                channels.error.subscribe(reject);\n                channels.response.subscribe((response)=>{\n                    resolve(options.onlyBody ? response.body : response);\n                });\n                setTimeout(()=>{\n                    try {\n                        channels.request.publish(context);\n                    } catch (err) {\n                        reject(err);\n                    }\n                }, 0);\n            })\n    };\n};\nclass Cancel {\n    constructor(message){\n        this.__CANCEL__ = true;\n        this.message = message;\n    }\n    toString() {\n        return \"Cancel\".concat(this.message ? \": \".concat(this.message) : \"\");\n    }\n}\nconst _CancelToken = class _CancelToken {\n    constructor(executor){\n        if (typeof executor !== \"function\") {\n            throw new TypeError(\"executor must be a function.\");\n        }\n        let resolvePromise = null;\n        this.promise = new Promise((resolve)=>{\n            resolvePromise = resolve;\n        });\n        executor((message)=>{\n            if (this.reason) {\n                return;\n            }\n            this.reason = new Cancel(message);\n            resolvePromise(this.reason);\n        });\n    }\n};\n_CancelToken.source = ()=>{\n    let cancel;\n    const token = new _CancelToken((can)=>{\n        cancel = can;\n    });\n    return {\n        token,\n        cancel\n    };\n};\nlet CancelToken = _CancelToken;\nconst isCancel = (value)=>!!(value && (value == null ? void 0 : value.__CANCEL__));\npromise.Cancel = Cancel;\npromise.CancelToken = CancelToken;\npromise.isCancel = isCancel;\nfunction proxy(_proxy) {\n    if (_proxy !== false && (!_proxy || !_proxy.host)) {\n        throw new Error(\"Proxy middleware takes an object of host, port and auth properties\");\n    }\n    return {\n        processOptions: (options)=>Object.assign({\n                proxy: _proxy\n            }, options)\n    };\n}\nvar defaultShouldRetry = (err, attempt, options)=>{\n    if (options.method !== \"GET\" && options.method !== \"HEAD\") {\n        return false;\n    }\n    return err.isNetworkError || false;\n};\nconst isStream = (stream)=>stream !== null && typeof stream === \"object\" && typeof stream.pipe === \"function\";\nvar sharedRetry = (opts)=>{\n    const maxRetries = opts.maxRetries || 5;\n    const retryDelay = opts.retryDelay || getRetryDelay;\n    const allowRetry = opts.shouldRetry;\n    return {\n        onError: (err, context)=>{\n            const options = context.options;\n            const max = options.maxRetries || maxRetries;\n            const shouldRetry = options.shouldRetry || allowRetry;\n            const attemptNumber = options.attemptNumber || 0;\n            if (isStream(options.body)) {\n                return err;\n            }\n            if (!shouldRetry(err, attemptNumber, options) || attemptNumber >= max) {\n                return err;\n            }\n            const newContext = Object.assign({}, context, {\n                options: Object.assign({}, options, {\n                    attemptNumber: attemptNumber + 1\n                })\n            });\n            setTimeout(()=>context.channels.request.publish(newContext), retryDelay(attemptNumber));\n            return null;\n        }\n    };\n};\nfunction getRetryDelay(attemptNum) {\n    return 100 * Math.pow(2, attemptNum) + Math.random() * 100;\n}\nconst retry = function() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return sharedRetry({\n        shouldRetry: defaultShouldRetry,\n        ...opts\n    });\n};\nretry.shouldRetry = defaultShouldRetry;\nfunction encode(data) {\n    const query = new URLSearchParams();\n    const nest = (name, _value)=>{\n        const value = _value instanceof Set ? Array.from(_value) : _value;\n        if (Array.isArray(value)) {\n            if (value.length) {\n                for(const index in value){\n                    nest(\"\".concat(name, \"[\").concat(index, \"]\"), value[index]);\n                }\n            } else {\n                query.append(\"\".concat(name, \"[]\"), \"\");\n            }\n        } else if (typeof value === \"object\" && value !== null) {\n            for (const [key, obj] of Object.entries(value)){\n                nest(\"\".concat(name, \"[\").concat(key, \"]\"), obj);\n            }\n        } else {\n            query.append(name, value);\n        }\n    };\n    for (const [key, value] of Object.entries(data)){\n        nest(key, value);\n    }\n    return query.toString();\n}\nfunction urlEncoded() {\n    return {\n        processOptions: (options)=>{\n            const body = options.body;\n            if (!body) {\n                return options;\n            }\n            const isStream = typeof body.pipe === \"function\";\n            const shouldSerialize = !isStream && !isBuffer(body) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_2__.isPlainObject)(body);\n            if (!shouldSerialize) {\n                return options;\n            }\n            return {\n                ...options,\n                body: encode(options.body),\n                headers: {\n                    ...options.headers,\n                    \"Content-Type\": \"application/x-www-form-urlencoded\"\n                }\n            };\n        }\n    };\n}\nfunction buildKeepAlive(agent) {\n    return function keepAlive() {\n        let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        const ms = config.ms || 1e3;\n        const maxFree = config.maxFree || 256;\n        const agentOptions = {\n            keepAlive: true,\n            keepAliveMsecs: ms,\n            maxFreeSockets: maxFree\n        };\n        return agent(agentOptions);\n    };\n}\nconst keepAlive = buildKeepAlive(agent);\n //# sourceMappingURL=middleware.browser.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvbWlkZGxld2FyZS5icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTRCO0FBQ29FO0FBQ2hEO0FBQ2hELFNBQVNJLE1BQU1DLElBQUk7SUFDakIsT0FBTyxDQUFDO0FBQ1Y7QUFDQSxNQUFNQyxlQUFlO0FBQ3JCLE1BQU1DLGdCQUFnQjtBQUN0QixTQUFTQyxLQUFLQyxPQUFPO0lBQ25CLE1BQU1DLFVBQVVELFFBQVFFLE9BQU8sQ0FBQ0osZUFBZTtJQUMvQyxPQUFPO1FBQ0xOLGdCQUFnQlcsQ0FBQUE7WUFDZCxJQUFJLGdCQUFnQkMsSUFBSSxDQUFDRCxRQUFRRSxHQUFHLEdBQUc7Z0JBQ3JDLE9BQU9GO1lBQ1Q7WUFDQSxNQUFNRSxNQUFNO2dCQUFDSjtnQkFBU0UsUUFBUUUsR0FBRyxDQUFDSCxPQUFPLENBQUNMLGNBQWM7YUFBSSxDQUFDUyxJQUFJLENBQUM7WUFDbEUsT0FBT0MsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR0wsU0FBUztnQkFDaENFO1lBQ0Y7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxNQUFNSSxvQkFBb0I7SUFBQztJQUFVO0NBQWdCO0FBQ3JELE1BQU1DLFNBQVNILE9BQU9JLFNBQVMsQ0FBQ0MsY0FBYztBQUM5QyxNQUFNQyxhQUFhLENBQUNDLFFBQVFDO0lBQzFCLE1BQU1DLFNBQVMsQ0FBQztJQUNoQixJQUFLLE1BQU1DLE9BQU9ILE9BQVE7UUFDeEIsSUFBSUosT0FBT1EsSUFBSSxDQUFDSixRQUFRRyxNQUFNO1lBQzVCRCxNQUFNLENBQUNDLElBQUksR0FBR0YsU0FBU0ksT0FBTyxDQUFDRixJQUFJRyxXQUFXLE1BQU0sQ0FBQyxJQUFJLGVBQWVOLE1BQU0sQ0FBQ0csSUFBSTtRQUNyRjtJQUNGO0lBQ0EsT0FBT0Q7QUFDVDtBQUNBLFNBQVNLO0lBQ1AsSUFBSXpCLE9BQU8wQixVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFD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UyxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQ2xGLE1BQU1zSyxLQUFLL0YsT0FBTytGLEVBQUUsSUFBSTtRQUN4QixNQUFNQyxVQUFVaEcsT0FBT2dHLE9BQU8sSUFBSTtRQUNsQyxNQUFNQyxlQUFlO1lBQ25CSCxXQUFXO1lBQ1hJLGdCQUFnQkg7WUFDaEJJLGdCQUFnQkg7UUFDbEI7UUFDQSxPQUFPbE0sTUFBTW1NO0lBQ2Y7QUFDRjtBQUNBLE1BQU1ILFlBQVlELGVBQWUvTDtBQUM0SixDQUM3TCw4Q0FBOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMtY29tbWVyY2UteXQtYnktbWlrZS8uL25vZGVfbW9kdWxlcy9nZXQtaXQvZGlzdC9taWRkbGV3YXJlLmJyb3dzZXIuanM/ZjYzMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZGVidWdJdCBmcm9tICdkZWJ1Zyc7XG5leHBvcnQgeyBwcm9jZXNzT3B0aW9ucywgdmFsaWRhdGVPcHRpb25zIH0gZnJvbSAnLi9fY2h1bmtzL2RlZmF1bHRPcHRpb25zVmFsaWRhdG9yLWRpdHR3TDdkLmpzJztcbmltcG9ydCB7IGlzUGxhaW5PYmplY3QgfSBmcm9tICdpcy1wbGFpbi1vYmplY3QnO1xuZnVuY3Rpb24gYWdlbnQob3B0cykge1xuICByZXR1cm4ge307XG59XG5jb25zdCBsZWFkaW5nU2xhc2ggPSAvXlxcLy87XG5jb25zdCB0cmFpbGluZ1NsYXNoID0gL1xcLyQvO1xuZnVuY3Rpb24gYmFzZShiYXNlVXJsKSB7XG4gIGNvbnN0IGJhc2VVcmkgPSBiYXNlVXJsLnJlcGxhY2UodHJhaWxpbmdTbGFzaCwgXCJcIik7XG4gIHJldHVybiB7XG4gICAgcHJvY2Vzc09wdGlvbnM6IG9wdGlvbnMgPT4ge1xuICAgICAgaWYgKC9eaHR0cHM/OlxcL1xcLy9pLnRlc3Qob3B0aW9ucy51cmwpKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgfVxuICAgICAgY29uc3QgdXJsID0gW2Jhc2VVcmksIG9wdGlvbnMudXJsLnJlcGxhY2UobGVhZGluZ1NsYXNoLCBcIlwiKV0uam9pbihcIi9cIik7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICB1cmxcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IFNFTlNJVElWRV9IRUFERVJTID0gW1wiY29va2llXCIsIFwiYXV0aG9yaXphdGlvblwiXTtcbmNvbnN0IGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5jb25zdCByZWRhY3RLZXlzID0gKHNvdXJjZSwgcmVkYWN0ZWQpID0+IHtcbiAgY29uc3QgdGFyZ2V0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSkge1xuICAgIGlmIChoYXNPd24uY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgIHRhcmdldFtrZXldID0gcmVkYWN0ZWQuaW5kZXhPZihrZXkudG9Mb3dlckNhc2UoKSkgPiAtMSA/IFwiPHJlZGFjdGVkPlwiIDogc291cmNlW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuZnVuY3Rpb24gZGVidWcoKSB7XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgY29uc3QgdmVyYm9zZSA9IG9wdHMudmVyYm9zZTtcbiAgY29uc3QgbmFtZXNwYWNlID0gb3B0cy5uYW1lc3BhY2UgfHwgXCJnZXQtaXRcIjtcbiAgY29uc3QgZGVmYXVsdExvZ2dlciA9IGRlYnVnSXQobmFtZXNwYWNlKTtcbiAgY29uc3QgbG9nID0gb3B0cy5sb2cgfHwgZGVmYXVsdExvZ2dlcjtcbiAgY29uc3Qgc2hvcnRDaXJjdWl0ID0gbG9nID09PSBkZWZhdWx0TG9nZ2VyICYmICFkZWJ1Z0l0LmVuYWJsZWQobmFtZXNwYWNlKTtcbiAgbGV0IHJlcXVlc3RJZCA9IDA7XG4gIHJldHVybiB7XG4gICAgcHJvY2Vzc09wdGlvbnM6IG9wdGlvbnMgPT4ge1xuICAgICAgb3B0aW9ucy5kZWJ1ZyA9IGxvZztcbiAgICAgIG9wdGlvbnMucmVxdWVzdElkID0gb3B0aW9ucy5yZXF1ZXN0SWQgfHwgKytyZXF1ZXN0SWQ7XG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9LFxuICAgIG9uUmVxdWVzdDogZXZlbnQgPT4ge1xuICAgICAgaWYgKHNob3J0Q2lyY3VpdCB8fCAhZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IGV2ZW50Lm9wdGlvbnM7XG4gICAgICBsb2coXCJbJXNdIEhUVFAgJXMgJXNcIiwgb3B0aW9ucy5yZXF1ZXN0SWQsIG9wdGlvbnMubWV0aG9kLCBvcHRpb25zLnVybCk7XG4gICAgICBpZiAodmVyYm9zZSAmJiBvcHRpb25zLmJvZHkgJiYgdHlwZW9mIG9wdGlvbnMuYm9keSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBsb2coXCJbJXNdIFJlcXVlc3QgYm9keTogJXNcIiwgb3B0aW9ucy5yZXF1ZXN0SWQsIG9wdGlvbnMuYm9keSk7XG4gICAgICB9XG4gICAgICBpZiAodmVyYm9zZSAmJiBvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG9wdHMucmVkYWN0U2Vuc2l0aXZlSGVhZGVycyA9PT0gZmFsc2UgPyBvcHRpb25zLmhlYWRlcnMgOiByZWRhY3RLZXlzKG9wdGlvbnMuaGVhZGVycywgU0VOU0lUSVZFX0hFQURFUlMpO1xuICAgICAgICBsb2coXCJbJXNdIFJlcXVlc3QgaGVhZGVyczogJXNcIiwgb3B0aW9ucy5yZXF1ZXN0SWQsIEpTT04uc3RyaW5naWZ5KGhlYWRlcnMsIG51bGwsIDIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9LFxuICAgIG9uUmVzcG9uc2U6IChyZXMsIGNvbnRleHQpID0+IHtcbiAgICAgIGlmIChzaG9ydENpcmN1aXQgfHwgIXJlcykge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVxSWQgPSBjb250ZXh0Lm9wdGlvbnMucmVxdWVzdElkO1xuICAgICAgbG9nKFwiWyVzXSBSZXNwb25zZSBjb2RlOiAlcyAlc1wiLCByZXFJZCwgcmVzLnN0YXR1c0NvZGUsIHJlcy5zdGF0dXNNZXNzYWdlKTtcbiAgICAgIGlmICh2ZXJib3NlICYmIHJlcy5ib2R5KSB7XG4gICAgICAgIGxvZyhcIlslc10gUmVzcG9uc2UgYm9keTogJXNcIiwgcmVxSWQsIHN0cmluZ2lmeUJvZHkocmVzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgb25FcnJvcjogKGVyciwgY29udGV4dCkgPT4ge1xuICAgICAgY29uc3QgcmVxSWQgPSBjb250ZXh0Lm9wdGlvbnMucmVxdWVzdElkO1xuICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgbG9nKFwiWyVzXSBFcnJvciBlbmNvdW50ZXJlZCwgYnV0IGhhbmRsZWQgYnkgYW4gZWFybGllciBtaWRkbGV3YXJlXCIsIHJlcUlkKTtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgIH1cbiAgICAgIGxvZyhcIlslc10gRVJST1I6ICVzXCIsIHJlcUlkLCBlcnIubWVzc2FnZSk7XG4gICAgICByZXR1cm4gZXJyO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeUJvZHkocmVzKSB7XG4gIGNvbnN0IGNvbnRlbnRUeXBlID0gKHJlcy5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IGlzSnNvbiA9IGNvbnRlbnRUeXBlLmluZGV4T2YoXCJhcHBsaWNhdGlvbi9qc29uXCIpICE9PSAtMTtcbiAgcmV0dXJuIGlzSnNvbiA/IHRyeUZvcm1hdChyZXMuYm9keSkgOiByZXMuYm9keTtcbn1cbmZ1bmN0aW9uIHRyeUZvcm1hdChib2R5KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcGFyc2VkID0gdHlwZW9mIGJvZHkgPT09IFwic3RyaW5nXCIgPyBKU09OLnBhcnNlKGJvZHkpIDogYm9keTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGFyc2VkLCBudWxsLCAyKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhlYWRlcnMoX2hlYWRlcnMpIHtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICByZXR1cm4ge1xuICAgIHByb2Nlc3NPcHRpb25zOiBvcHRpb25zID0+IHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9O1xuICAgICAgb3B0aW9ucy5oZWFkZXJzID0gb3B0cy5vdmVycmlkZSA/IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLCBfaGVhZGVycykgOiBPYmplY3QuYXNzaWduKHt9LCBfaGVhZGVycywgZXhpc3RpbmcpO1xuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICB9O1xufVxuY2xhc3MgSHR0cEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZXMsIGN0eCkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3QgdHJ1bmNhdGVkVXJsID0gcmVzLnVybC5sZW5ndGggPiA0MDAgPyBcIlwiLmNvbmNhdChyZXMudXJsLnNsaWNlKDAsIDM5OSksIFwiXFx1MjAyNlwiKSA6IHJlcy51cmw7XG4gICAgbGV0IG1zZyA9IFwiXCIuY29uY2F0KHJlcy5tZXRob2QsIFwiLXJlcXVlc3QgdG8gXCIpLmNvbmNhdCh0cnVuY2F0ZWRVcmwsIFwiIHJlc3VsdGVkIGluIFwiKTtcbiAgICBtc2cgKz0gXCJIVFRQIFwiLmNvbmNhdChyZXMuc3RhdHVzQ29kZSwgXCIgXCIpLmNvbmNhdChyZXMuc3RhdHVzTWVzc2FnZSk7XG4gICAgdGhpcy5tZXNzYWdlID0gbXNnLnRyaW0oKTtcbiAgICB0aGlzLnJlc3BvbnNlID0gcmVzO1xuICAgIHRoaXMucmVxdWVzdCA9IGN0eC5vcHRpb25zO1xuICB9XG59XG5mdW5jdGlvbiBodHRwRXJyb3JzKCkge1xuICByZXR1cm4ge1xuICAgIG9uUmVzcG9uc2U6IChyZXMsIGN0eCkgPT4ge1xuICAgICAgY29uc3QgaXNIdHRwRXJyb3IgPSByZXMuc3RhdHVzQ29kZSA+PSA0MDA7XG4gICAgICBpZiAoIWlzSHR0cEVycm9yKSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgSHR0cEVycm9yKHJlcywgY3R4KTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBpbmplY3RSZXNwb25zZSgpIHtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICBpZiAodHlwZW9mIG9wdHMuaW5qZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJgaW5qZWN0UmVzcG9uc2VgIG1pZGRsZXdhcmUgcmVxdWlyZXMgYSBgaW5qZWN0YCBmdW5jdGlvblwiKTtcbiAgfVxuICBjb25zdCBpbmplY3QgPSBmdW5jdGlvbiBpbmplY3QyKHByZXZWYWx1ZSwgZXZlbnQpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IG9wdHMuaW5qZWN0KGV2ZW50LCBwcmV2VmFsdWUpO1xuICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiBwcmV2VmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMgPSBldmVudC5jb250ZXh0Lm9wdGlvbnM7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJvZHk6IFwiXCIsXG4gICAgICB1cmw6IG9wdGlvbnMudXJsLFxuICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgc3RhdHVzQ29kZTogMjAwLFxuICAgICAgc3RhdHVzTWVzc2FnZTogXCJPS1wiLFxuICAgICAgLi4ucmVzcG9uc2VcbiAgICB9O1xuICB9O1xuICByZXR1cm4ge1xuICAgIGludGVyY2VwdFJlcXVlc3Q6IGluamVjdFxuICB9O1xufVxuY29uc3QgaXNCdWZmZXIgPSB0eXBlb2YgQnVmZmVyID09PSBcInVuZGVmaW5lZFwiID8gKCkgPT4gZmFsc2UgOiBvYmogPT4gQnVmZmVyLmlzQnVmZmVyKG9iaik7XG5jb25zdCBzZXJpYWxpemVUeXBlcyA9IFtcImJvb2xlYW5cIiwgXCJzdHJpbmdcIiwgXCJudW1iZXJcIl07XG5mdW5jdGlvbiBqc29uUmVxdWVzdCgpIHtcbiAgcmV0dXJuIHtcbiAgICBwcm9jZXNzT3B0aW9uczogb3B0aW9ucyA9PiB7XG4gICAgICBjb25zdCBib2R5ID0gb3B0aW9ucy5ib2R5O1xuICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNTdHJlYW0gPSB0eXBlb2YgYm9keS5waXBlID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICBjb25zdCBzaG91bGRTZXJpYWxpemUgPSAhaXNTdHJlYW0gJiYgIWlzQnVmZmVyKGJvZHkpICYmIChzZXJpYWxpemVUeXBlcy5pbmRleE9mKHR5cGVvZiBib2R5KSAhPT0gLTEgfHwgQXJyYXkuaXNBcnJheShib2R5KSB8fCBpc1BsYWluT2JqZWN0KGJvZHkpKTtcbiAgICAgIGlmICghc2hvdWxkU2VyaWFsaXplKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5ib2R5KSxcbiAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5oZWFkZXJzLCB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGpzb25SZXNwb25zZShvcHRzKSB7XG4gIHJldHVybiB7XG4gICAgb25SZXNwb25zZTogcmVzcG9uc2UgPT4ge1xuICAgICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdIHx8IFwiXCI7XG4gICAgICBjb25zdCBzaG91bGREZWNvZGUgPSBvcHRzICYmIG9wdHMuZm9yY2UgfHwgY29udGVudFR5cGUuaW5kZXhPZihcImFwcGxpY2F0aW9uL2pzb25cIikgIT09IC0xO1xuICAgICAgaWYgKCFyZXNwb25zZS5ib2R5IHx8ICFjb250ZW50VHlwZSB8fCAhc2hvdWxkRGVjb2RlKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCByZXNwb25zZSwge1xuICAgICAgICBib2R5OiB0cnlQYXJzZShyZXNwb25zZS5ib2R5KVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBwcm9jZXNzT3B0aW9uczogb3B0aW9ucyA9PiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgfSwgb3B0aW9ucy5oZWFkZXJzKVxuICAgIH0pXG4gIH07XG4gIGZ1bmN0aW9uIHRyeVBhcnNlKGJvZHkpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoYm9keSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBlcnIubWVzc2FnZSA9IFwiRmFpbGVkIHRvIHBhcnNlZCByZXNwb25zZSBib2R5IGFzIEpTT046IFwiLmNvbmNhdChlcnIubWVzc2FnZSk7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpc0Jyb3dzZXJPcHRpb25zKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMgIT09IG51bGwgJiYgIShcInByb3RvY29sXCIgaW4gb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBtdGxzKCkge1xuICBsZXQgY29uZmlnID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgaWYgKCFjb25maWcuY2EpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVpcmVkIG10bHMgb3B0aW9uIFwiY2FcIiBpcyBtaXNzaW5nJyk7XG4gIH1cbiAgaWYgKCFjb25maWcuY2VydCkge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVxdWlyZWQgbXRscyBvcHRpb24gXCJjZXJ0XCIgaXMgbWlzc2luZycpO1xuICB9XG4gIGlmICghY29uZmlnLmtleSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVxdWlyZWQgbXRscyBvcHRpb24gXCJrZXlcIiBpcyBtaXNzaW5nJyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBmaW5hbGl6ZU9wdGlvbnM6IG9wdGlvbnMgPT4ge1xuICAgICAgaWYgKGlzQnJvd3Nlck9wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICB9XG4gICAgICBjb25zdCBtdGxzT3B0cyA9IHtcbiAgICAgICAgY2VydDogY29uZmlnLmNlcnQsXG4gICAgICAgIGtleTogY29uZmlnLmtleSxcbiAgICAgICAgY2E6IGNvbmZpZy5jYVxuICAgICAgfTtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCBtdGxzT3B0cyk7XG4gICAgfVxuICB9O1xufVxubGV0IGFjdHVhbEdsb2JhbCA9IHt9O1xuaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIGFjdHVhbEdsb2JhbCA9IGdsb2JhbFRoaXM7XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgYWN0dWFsR2xvYmFsID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIGFjdHVhbEdsb2JhbCA9IGdsb2JhbDtcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgYWN0dWFsR2xvYmFsID0gc2VsZjtcbn1cbnZhciBnbG9iYWwkMSA9IGFjdHVhbEdsb2JhbDtcbmZ1bmN0aW9uIG9ic2VydmFibGUoKSB7XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgY29uc3QgT2JzZXJ2YWJsZSA9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55IC0tIEBUT0RPIGNvbnNpZGVyIGRyb3BwaW5nIGNoZWNraW5nIGZvciBhIGdsb2JhbCBPYnNlcnZhYmxlIHNpbmNlIGl0J3Mgbm90IG9uIGEgc3RhbmRhcmRzIHRyYWNrXG4gIG9wdHMuaW1wbGVtZW50YXRpb24gfHwgZ2xvYmFsJDEuT2JzZXJ2YWJsZTtcbiAgaWYgKCFPYnNlcnZhYmxlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYE9ic2VydmFibGVgIGlzIG5vdCBhdmFpbGFibGUgaW4gZ2xvYmFsIHNjb3BlLCBhbmQgbm8gaW1wbGVtZW50YXRpb24gd2FzIHBhc3NlZFwiKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG9uUmV0dXJuOiAoY2hhbm5lbHMsIGNvbnRleHQpID0+IG5ldyBPYnNlcnZhYmxlKG9ic2VydmVyID0+IHtcbiAgICAgIGNoYW5uZWxzLmVycm9yLnN1YnNjcmliZShlcnIgPT4gb2JzZXJ2ZXIuZXJyb3IoZXJyKSk7XG4gICAgICBjaGFubmVscy5wcm9ncmVzcy5zdWJzY3JpYmUoZXZlbnQgPT4gb2JzZXJ2ZXIubmV4dChPYmplY3QuYXNzaWduKHtcbiAgICAgICAgdHlwZTogXCJwcm9ncmVzc1wiXG4gICAgICB9LCBldmVudCkpKTtcbiAgICAgIGNoYW5uZWxzLnJlc3BvbnNlLnN1YnNjcmliZShyZXNwb25zZSA9PiB7XG4gICAgICAgIG9ic2VydmVyLm5leHQoT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgdHlwZTogXCJyZXNwb25zZVwiXG4gICAgICAgIH0sIHJlc3BvbnNlKSk7XG4gICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICB9KTtcbiAgICAgIGNoYW5uZWxzLnJlcXVlc3QucHVibGlzaChjb250ZXh0KTtcbiAgICAgIHJldHVybiAoKSA9PiBjaGFubmVscy5hYm9ydC5wdWJsaXNoKCk7XG4gICAgfSlcbiAgfTtcbn1cbmZ1bmN0aW9uIHByb2dyZXNzKCkge1xuICByZXR1cm4ge1xuICAgIG9uUmVxdWVzdDogZXZ0ID0+IHtcbiAgICAgIGlmIChldnQuYWRhcHRlciAhPT0gXCJ4aHJcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB4aHIgPSBldnQucmVxdWVzdDtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBldnQuY29udGV4dDtcbiAgICAgIGlmIChcInVwbG9hZFwiIGluIHhociAmJiBcIm9ucHJvZ3Jlc3NcIiBpbiB4aHIudXBsb2FkKSB7XG4gICAgICAgIHhoci51cGxvYWQub25wcm9ncmVzcyA9IGhhbmRsZVByb2dyZXNzKFwidXBsb2FkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKFwib25wcm9ncmVzc1wiIGluIHhocikge1xuICAgICAgICB4aHIub25wcm9ncmVzcyA9IGhhbmRsZVByb2dyZXNzKFwiZG93bmxvYWRcIik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBoYW5kbGVQcm9ncmVzcyhzdGFnZSkge1xuICAgICAgICByZXR1cm4gZXZlbnQgPT4ge1xuICAgICAgICAgIGNvbnN0IHBlcmNlbnQgPSBldmVudC5sZW5ndGhDb21wdXRhYmxlID8gZXZlbnQubG9hZGVkIC8gZXZlbnQudG90YWwgKiAxMDAgOiAtMTtcbiAgICAgICAgICBjb250ZXh0LmNoYW5uZWxzLnByb2dyZXNzLnB1Ymxpc2goe1xuICAgICAgICAgICAgc3RhZ2UsXG4gICAgICAgICAgICBwZXJjZW50LFxuICAgICAgICAgICAgdG90YWw6IGV2ZW50LnRvdGFsLFxuICAgICAgICAgICAgbG9hZGVkOiBldmVudC5sb2FkZWQsXG4gICAgICAgICAgICBsZW5ndGhDb21wdXRhYmxlOiBldmVudC5sZW5ndGhDb21wdXRhYmxlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuY29uc3QgcHJvbWlzZSA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICBjb25zdCBQcm9taXNlSW1wbGVtZW50YXRpb24gPSBvcHRpb25zLmltcGxlbWVudGF0aW9uIHx8IFByb21pc2U7XG4gIGlmICghUHJvbWlzZUltcGxlbWVudGF0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYFByb21pc2VgIGlzIG5vdCBhdmFpbGFibGUgaW4gZ2xvYmFsIHNjb3BlLCBhbmQgbm8gaW1wbGVtZW50YXRpb24gd2FzIHBhc3NlZFwiKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG9uUmV0dXJuOiAoY2hhbm5lbHMsIGNvbnRleHQpID0+IG5ldyBQcm9taXNlSW1wbGVtZW50YXRpb24oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgY2FuY2VsID0gY29udGV4dC5vcHRpb25zLmNhbmNlbFRva2VuO1xuICAgICAgaWYgKGNhbmNlbCkge1xuICAgICAgICBjYW5jZWwucHJvbWlzZS50aGVuKHJlYXNvbiA9PiB7XG4gICAgICAgICAgY2hhbm5lbHMuYWJvcnQucHVibGlzaChyZWFzb24pO1xuICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNoYW5uZWxzLmVycm9yLnN1YnNjcmliZShyZWplY3QpO1xuICAgICAgY2hhbm5lbHMucmVzcG9uc2Uuc3Vic2NyaWJlKHJlc3BvbnNlID0+IHtcbiAgICAgICAgcmVzb2x2ZShvcHRpb25zLm9ubHlCb2R5ID8gcmVzcG9uc2UuYm9keSA6IHJlc3BvbnNlKTtcbiAgICAgIH0pO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2hhbm5lbHMucmVxdWVzdC5wdWJsaXNoKGNvbnRleHQpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSwgMCk7XG4gICAgfSlcbiAgfTtcbn07XG5jbGFzcyBDYW5jZWwge1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5fX0NBTkNFTF9fID0gdHJ1ZTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBcIkNhbmNlbFwiLmNvbmNhdCh0aGlzLm1lc3NhZ2UgPyBcIjogXCIuY29uY2F0KHRoaXMubWVzc2FnZSkgOiBcIlwiKTtcbiAgfVxufVxuY29uc3QgX0NhbmNlbFRva2VuID0gY2xhc3MgX0NhbmNlbFRva2VuIHtcbiAgY29uc3RydWN0b3IoZXhlY3V0b3IpIHtcbiAgICBpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cbiAgICBsZXQgcmVzb2x2ZVByb21pc2UgPSBudWxsO1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIGV4ZWN1dG9yKG1lc3NhZ2UgPT4ge1xuICAgICAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVhc29uID0gbmV3IENhbmNlbChtZXNzYWdlKTtcbiAgICAgIHJlc29sdmVQcm9taXNlKHRoaXMucmVhc29uKTtcbiAgICB9KTtcbiAgfVxufTtcbl9DYW5jZWxUb2tlbi5zb3VyY2UgPSAoKSA9PiB7XG4gIGxldCBjYW5jZWw7XG4gIGNvbnN0IHRva2VuID0gbmV3IF9DYW5jZWxUb2tlbihjYW4gPT4ge1xuICAgIGNhbmNlbCA9IGNhbjtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdG9rZW4sXG4gICAgY2FuY2VsXG4gIH07XG59O1xubGV0IENhbmNlbFRva2VuID0gX0NhbmNlbFRva2VuO1xuY29uc3QgaXNDYW5jZWwgPSB2YWx1ZSA9PiAhISh2YWx1ZSAmJiAodmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IHZhbHVlLl9fQ0FOQ0VMX18pKTtcbnByb21pc2UuQ2FuY2VsID0gQ2FuY2VsO1xucHJvbWlzZS5DYW5jZWxUb2tlbiA9IENhbmNlbFRva2VuO1xucHJvbWlzZS5pc0NhbmNlbCA9IGlzQ2FuY2VsO1xuZnVuY3Rpb24gcHJveHkoX3Byb3h5KSB7XG4gIGlmIChfcHJveHkgIT09IGZhbHNlICYmICghX3Byb3h5IHx8ICFfcHJveHkuaG9zdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm94eSBtaWRkbGV3YXJlIHRha2VzIGFuIG9iamVjdCBvZiBob3N0LCBwb3J0IGFuZCBhdXRoIHByb3BlcnRpZXNcIik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwcm9jZXNzT3B0aW9uczogb3B0aW9ucyA9PiBPYmplY3QuYXNzaWduKHtcbiAgICAgIHByb3h5OiBfcHJveHlcbiAgICB9LCBvcHRpb25zKVxuICB9O1xufVxudmFyIGRlZmF1bHRTaG91bGRSZXRyeSA9IChlcnIsIGF0dGVtcHQsIG9wdGlvbnMpID0+IHtcbiAgaWYgKG9wdGlvbnMubWV0aG9kICE9PSBcIkdFVFwiICYmIG9wdGlvbnMubWV0aG9kICE9PSBcIkhFQURcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gZXJyLmlzTmV0d29ya0Vycm9yIHx8IGZhbHNlO1xufTtcbmNvbnN0IGlzU3RyZWFtID0gc3RyZWFtID0+IHN0cmVhbSAhPT0gbnVsbCAmJiB0eXBlb2Ygc3RyZWFtID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBzdHJlYW0ucGlwZSA9PT0gXCJmdW5jdGlvblwiO1xudmFyIHNoYXJlZFJldHJ5ID0gb3B0cyA9PiB7XG4gIGNvbnN0IG1heFJldHJpZXMgPSBvcHRzLm1heFJldHJpZXMgfHwgNTtcbiAgY29uc3QgcmV0cnlEZWxheSA9IG9wdHMucmV0cnlEZWxheSB8fCBnZXRSZXRyeURlbGF5O1xuICBjb25zdCBhbGxvd1JldHJ5ID0gb3B0cy5zaG91bGRSZXRyeTtcbiAgcmV0dXJuIHtcbiAgICBvbkVycm9yOiAoZXJyLCBjb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBvcHRpb25zID0gY29udGV4dC5vcHRpb25zO1xuICAgICAgY29uc3QgbWF4ID0gb3B0aW9ucy5tYXhSZXRyaWVzIHx8IG1heFJldHJpZXM7XG4gICAgICBjb25zdCBzaG91bGRSZXRyeSA9IG9wdGlvbnMuc2hvdWxkUmV0cnkgfHwgYWxsb3dSZXRyeTtcbiAgICAgIGNvbnN0IGF0dGVtcHROdW1iZXIgPSBvcHRpb25zLmF0dGVtcHROdW1iZXIgfHwgMDtcbiAgICAgIGlmIChpc1N0cmVhbShvcHRpb25zLmJvZHkpKSB7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgICB9XG4gICAgICBpZiAoIXNob3VsZFJldHJ5KGVyciwgYXR0ZW1wdE51bWJlciwgb3B0aW9ucykgfHwgYXR0ZW1wdE51bWJlciA+PSBtYXgpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld0NvbnRleHQgPSBPYmplY3QuYXNzaWduKHt9LCBjb250ZXh0LCB7XG4gICAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICBhdHRlbXB0TnVtYmVyOiBhdHRlbXB0TnVtYmVyICsgMVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IGNvbnRleHQuY2hhbm5lbHMucmVxdWVzdC5wdWJsaXNoKG5ld0NvbnRleHQpLCByZXRyeURlbGF5KGF0dGVtcHROdW1iZXIpKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcbn07XG5mdW5jdGlvbiBnZXRSZXRyeURlbGF5KGF0dGVtcHROdW0pIHtcbiAgcmV0dXJuIDEwMCAqIE1hdGgucG93KDIsIGF0dGVtcHROdW0pICsgTWF0aC5yYW5kb20oKSAqIDEwMDtcbn1cbmNvbnN0IHJldHJ5ID0gZnVuY3Rpb24gKCkge1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHJldHVybiBzaGFyZWRSZXRyeSh7XG4gICAgc2hvdWxkUmV0cnk6IGRlZmF1bHRTaG91bGRSZXRyeSxcbiAgICAuLi5vcHRzXG4gIH0pO1xufTtcbnJldHJ5LnNob3VsZFJldHJ5ID0gZGVmYXVsdFNob3VsZFJldHJ5O1xuZnVuY3Rpb24gZW5jb2RlKGRhdGEpIHtcbiAgY29uc3QgcXVlcnkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gIGNvbnN0IG5lc3QgPSAobmFtZSwgX3ZhbHVlKSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBfdmFsdWUgaW5zdGFuY2VvZiBTZXQgPyBBcnJheS5mcm9tKF92YWx1ZSkgOiBfdmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBpZiAodmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIGZvciAoY29uc3QgaW5kZXggaW4gdmFsdWUpIHtcbiAgICAgICAgICBuZXN0KFwiXCIuY29uY2F0KG5hbWUsIFwiW1wiKS5jb25jYXQoaW5kZXgsIFwiXVwiKSwgdmFsdWVbaW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVlcnkuYXBwZW5kKFwiXCIuY29uY2F0KG5hbWUsIFwiW11cIiksIFwiXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIG9ial0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgIG5lc3QoXCJcIi5jb25jYXQobmFtZSwgXCJbXCIpLmNvbmNhdChrZXksIFwiXVwiKSwgb2JqKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcXVlcnkuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gIH07XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGRhdGEpKSB7XG4gICAgbmVzdChrZXksIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcXVlcnkudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIHVybEVuY29kZWQoKSB7XG4gIHJldHVybiB7XG4gICAgcHJvY2Vzc09wdGlvbnM6IG9wdGlvbnMgPT4ge1xuICAgICAgY29uc3QgYm9keSA9IG9wdGlvbnMuYm9keTtcbiAgICAgIGlmICghYm9keSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzU3RyZWFtID0gdHlwZW9mIGJvZHkucGlwZSA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgY29uc3Qgc2hvdWxkU2VyaWFsaXplID0gIWlzU3RyZWFtICYmICFpc0J1ZmZlcihib2R5KSAmJiBpc1BsYWluT2JqZWN0KGJvZHkpO1xuICAgICAgaWYgKCFzaG91bGRTZXJpYWxpemUpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBib2R5OiBlbmNvZGUob3B0aW9ucy5ib2R5KSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gYnVpbGRLZWVwQWxpdmUoYWdlbnQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGtlZXBBbGl2ZSgpIHtcbiAgICBsZXQgY29uZmlnID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjb25zdCBtcyA9IGNvbmZpZy5tcyB8fCAxZTM7XG4gICAgY29uc3QgbWF4RnJlZSA9IGNvbmZpZy5tYXhGcmVlIHx8IDI1NjtcbiAgICBjb25zdCBhZ2VudE9wdGlvbnMgPSB7XG4gICAgICBrZWVwQWxpdmU6IHRydWUsXG4gICAgICBrZWVwQWxpdmVNc2VjczogbXMsXG4gICAgICBtYXhGcmVlU29ja2V0czogbWF4RnJlZVxuICAgIH07XG4gICAgcmV0dXJuIGFnZW50KGFnZW50T3B0aW9ucyk7XG4gIH07XG59XG5jb25zdCBrZWVwQWxpdmUgPSBidWlsZEtlZXBBbGl2ZShhZ2VudCk7XG5leHBvcnQgeyBDYW5jZWwsIENhbmNlbFRva2VuLCBhZ2VudCwgYmFzZSwgZGVidWcsIGhlYWRlcnMsIGh0dHBFcnJvcnMsIGluamVjdFJlc3BvbnNlLCBqc29uUmVxdWVzdCwganNvblJlc3BvbnNlLCBrZWVwQWxpdmUsIG10bHMsIG9ic2VydmFibGUsIHByb2dyZXNzLCBwcm9taXNlLCBwcm94eSwgcmV0cnksIHVybEVuY29kZWQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pZGRsZXdhcmUuYnJvd3Nlci5qcy5tYXBcbiJdLCJuYW1lcyI6WyJkZWJ1Z0l0IiwicHJvY2Vzc09wdGlvbnMiLCJ2YWxpZGF0ZU9wdGlvbnMiLCJpc1BsYWluT2JqZWN0IiwiYWdlbnQiLCJvcHRzIiwibGVhZGluZ1NsYXNoIiwidHJhaWxpbmdTbGFzaCIsImJhc2UiLCJiYXNlVXJsIiwiYmFzZVVyaSIsInJlcGxhY2UiLCJvcHRpb25zIiwidGVzdCIsInVybCIsImpvaW4iLCJPYmplY3QiLCJhc3NpZ24iLCJTRU5TSVRJVkVfSEVBREVSUyIsImhhc093biIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwicmVkYWN0S2V5cyIsInNvdXJjZSIsInJlZGFjdGVkIiwidGFyZ2V0Iiwia2V5IiwiY2FsbCIsImluZGV4T2YiLCJ0b0xvd2VyQ2FzZSIsImRlYnVnIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwidmVyYm9zZSIsIm5hbWVzcGFjZSIsImRlZmF1bHRMb2dnZXIiLCJsb2ciLCJzaG9ydENpcmN1aXQiLCJlbmFibGVkIiwicmVxdWVzdElkIiwib25SZXF1ZXN0IiwiZXZlbnQiLCJtZXRob2QiLCJib2R5IiwiaGVhZGVycyIsInJlZGFjdFNlbnNpdGl2ZUhlYWRlcnMiLCJKU09OIiwic3RyaW5naWZ5Iiwib25SZXNwb25zZSIsInJlcyIsImNvbnRleHQiLCJyZXFJZCIsInN0YXR1c0NvZGUiLCJzdGF0dXNNZXNzYWdlIiwic3RyaW5naWZ5Qm9keSIsIm9uRXJyb3IiLCJlcnIiLCJtZXNzYWdlIiwiY29udGVudFR5cGUiLCJpc0pzb24iLCJ0cnlGb3JtYXQiLCJwYXJzZWQiLCJwYXJzZSIsIl9oZWFkZXJzIiwiZXhpc3RpbmciLCJvdmVycmlkZSIsIkh0dHBFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJjdHgiLCJ0cnVuY2F0ZWRVcmwiLCJjb25jYXQiLCJzbGljZSIsIm1zZyIsInRyaW0iLCJyZXNwb25zZSIsInJlcXVlc3QiLCJodHRwRXJyb3JzIiwiaXNIdHRwRXJyb3IiLCJpbmplY3RSZXNwb25zZSIsImluamVjdCIsImluamVjdDIiLCJwcmV2VmFsdWUiLCJpbnRlcmNlcHRSZXF1ZXN0IiwiaXNCdWZmZXIiLCJCdWZmZXIiLCJvYmoiLCJzZXJpYWxpemVUeXBlcyIsImpzb25SZXF1ZXN0IiwiaXNTdHJlYW0iLCJwaXBlIiwic2hvdWxkU2VyaWFsaXplIiwiQXJyYXkiLCJpc0FycmF5IiwianNvblJlc3BvbnNlIiwic2hvdWxkRGVjb2RlIiwiZm9yY2UiLCJ0cnlQYXJzZSIsIkFjY2VwdCIsImlzQnJvd3Nlck9wdGlvbnMiLCJtdGxzIiwiY29uZmlnIiwiY2EiLCJjZXJ0IiwiZmluYWxpemVPcHRpb25zIiwibXRsc09wdHMiLCJhY3R1YWxHbG9iYWwiLCJnbG9iYWxUaGlzIiwid2luZG93IiwiZ2xvYmFsIiwic2VsZiIsImdsb2JhbCQxIiwib2JzZXJ2YWJsZSIsIk9ic2VydmFibGUiLCJpbXBsZW1lbnRhdGlvbiIsIm9uUmV0dXJuIiwiY2hhbm5lbHMiLCJvYnNlcnZlciIsImVycm9yIiwic3Vic2NyaWJlIiwicHJvZ3Jlc3MiLCJuZXh0IiwidHlwZSIsImNvbXBsZXRlIiwicHVibGlzaCIsImFib3J0IiwiZXZ0IiwiYWRhcHRlciIsInhociIsInVwbG9hZCIsIm9ucHJvZ3Jlc3MiLCJoYW5kbGVQcm9ncmVzcyIsInN0YWdlIiwicGVyY2VudCIsImxlbmd0aENvbXB1dGFibGUiLCJsb2FkZWQiLCJ0b3RhbCIsInByb21pc2UiLCJQcm9taXNlSW1wbGVtZW50YXRpb24iLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImNhbmNlbCIsImNhbmNlbFRva2VuIiwidGhlbiIsInJlYXNvbiIsIm9ubHlCb2R5Iiwic2V0VGltZW91dCIsIkNhbmNlbCIsIl9fQ0FOQ0VMX18iLCJ0b1N0cmluZyIsIl9DYW5jZWxUb2tlbiIsImV4ZWN1dG9yIiwiVHlwZUVycm9yIiwicmVzb2x2ZVByb21pc2UiLCJ0b2tlbiIsImNhbiIsIkNhbmNlbFRva2VuIiwiaXNDYW5jZWwiLCJ2YWx1ZSIsInByb3h5IiwiX3Byb3h5IiwiaG9zdCIsImRlZmF1bHRTaG91bGRSZXRyeSIsImF0dGVtcHQiLCJpc05ldHdvcmtFcnJvciIsInN0cmVhbSIsInNoYXJlZFJldHJ5IiwibWF4UmV0cmllcyIsInJldHJ5RGVsYXkiLCJnZXRSZXRyeURlbGF5IiwiYWxsb3dSZXRyeSIsInNob3VsZFJldHJ5IiwibWF4IiwiYXR0ZW1wdE51bWJlciIsIm5ld0NvbnRleHQiLCJhdHRlbXB0TnVtIiwiTWF0aCIsInBvdyIsInJhbmRvbSIsInJldHJ5IiwiZW5jb2RlIiwiZGF0YSIsInF1ZXJ5IiwiVVJMU2VhcmNoUGFyYW1zIiwibmVzdCIsIm5hbWUiLCJfdmFsdWUiLCJTZXQiLCJmcm9tIiwiaW5kZXgiLCJhcHBlbmQiLCJlbnRyaWVzIiwidXJsRW5jb2RlZCIsImJ1aWxkS2VlcEFsaXZlIiwia2VlcEFsaXZlIiwibXMiLCJtYXhGcmVlIiwiYWdlbnRPcHRpb25zIiwia2VlcEFsaXZlTXNlY3MiLCJtYXhGcmVlU29ja2V0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/get-it/dist/middleware.browser.js\n");

/***/ })

};
;